{
  
    
        "post0": {
            "title": "Developing inside a Container with VSCode",
            "content": "In this blog post, we will try to add a few files in our project folder, to start developing an existing project on the docker container with VSCode. We will be working on one of my python pet project. . If you are in a hurry and just want to go through the code, here is the github repo. Go through .devcontainer folder. . Let’s start…. . Pre-requisites: VSCode, Docker. . Architecture . The architecture of VS Code working with docker container - . . We won’t go into the details here. If you are interested, please read the documentation. . Installing Extension . Install Remote - Containers from extensions marketplace. . Create .devcontainer Folder . In our project, we need to create a .devcontainer folder. Here, we will keep our configuration files, which will be used to create our container for development purposes. This folder and its’ files will tell our recently installed extension to create a docker container and use it for development. . Create Dockerfile . I have modified the Dockerfile a little bit, according to my need. Except that, this file was copied from vscode-remote-try-python. This definition will be used to create our development container. . ARG VARIANT=3.8-bullseye FROM mcr.microsoft.com/vscode/devcontainers/python:0-${VARIANT} # [Choice] Node.js version: none, lts/*, 16, 14, 12, 10 ARG NODE_VERSION=&quot;none&quot; RUN if [ &quot;${NODE_VERSION}&quot; != &quot;none&quot; ]; then su vscode -c &quot;umask 0002 &amp;&amp; . /usr/local/share/nvm/nvm.sh &amp;&amp; nvm install ${NODE_VERSION} 2&gt;&amp;1&quot;; fi # [Optional] If your pip requirements rarely change, uncomment this section to add them to the image. COPY requirements.txt /tmp/pip-tmp/ COPY requirements.dev.txt /tmp/pip-tmp/ RUN pip3 --disable-pip-version-check --no-cache-dir install -r /tmp/pip-tmp/requirements.dev.txt &amp;&amp; rm -rf /tmp/pip-tmp . Create devcontainer.json . Now, we have our dockerfile to create a container from it. But we might want to pass some build/runtime arguments for our need, we can configure those in this file. We can also add the necessary vscode extension ids that will be needed for our development. And VSCode will take care of all of our configured needs. . There is one thing that I want to add here. I have a locally running PostgreSQL database. I was struggling to connect my application(which is running inside a container) with the local database. Special thanks to Sadman Amin, for suggesting me to use --network=host as an argument, and this resolved the issue. . { &quot;name&quot;: &quot;Python 3&quot;, &quot;build&quot;: { &quot;dockerfile&quot;: &quot;Dockerfile&quot;, &quot;context&quot;: &quot;..&quot;, &quot;args&quot;: { &quot;VARIANT&quot;: &quot;3.8-buster&quot;, &quot;NODE_VERSION&quot;: &quot;lts/*&quot;, } }, &quot;runArgs&quot;: [&quot;--network=host&quot;], // Set *default* container specific settings.json values on container create. &quot;settings&quot;: { &quot;terminal.integrated.profiles.linux&quot;: { &quot;bash&quot;: { &quot;path&quot;: &quot;/bin/bash&quot; } }, &quot;python.defaultInterpreterPath&quot;: &quot;/usr/local/bin/python&quot;, &quot;python.languageServer&quot;: &quot;Default&quot;, &quot;python.linting.enabled&quot;: true, &quot;python.linting.pylintEnabled&quot;: true, &quot;python.formatting.autopep8Path&quot;: &quot;/usr/local/py-utils/bin/autopep8&quot;, &quot;python.formatting.blackPath&quot;: &quot;/usr/local/py-utils/bin/black&quot;, &quot;python.formatting.yapfPath&quot;: &quot;/usr/local/py-utils/bin/yapf&quot;, &quot;python.linting.banditPath&quot;: &quot;/usr/local/py-utils/bin/bandit&quot;, &quot;python.linting.flake8Path&quot;: &quot;/usr/local/py-utils/bin/flake8&quot;, &quot;python.linting.mypyPath&quot;: &quot;/usr/local/py-utils/bin/mypy&quot;, &quot;python.linting.pycodestylePath&quot;: &quot;/usr/local/py-utils/bin/pycodestyle&quot;, &quot;python.linting.pydocstylePath&quot;: &quot;/usr/local/py-utils/bin/pydocstyle&quot;, &quot;python.linting.pylintPath&quot;: &quot;/usr/local/py-utils/bin/pylint&quot; }, // Add the IDs of extensions you want installed when the container is created. &quot;extensions&quot;: [ &quot;ms-python.python&quot;, &quot;ms-python.vscode-pylance&quot; ], // Use &#39;forwardPorts&#39; to make a list of ports inside the container available locally. &quot;forwardPorts&quot;: [8080], // Use &#39;portsAttributes&#39; to set default properties for specific forwarded ports. More info: https://code.visualstudio.com/docs/remote/devcontainerjson-reference. &quot;portsAttributes&quot;: { &quot;8080&quot;: { &quot;label&quot;: &quot;DVD Rental&quot;, &quot;onAutoForward&quot;: &quot;notify&quot; } }, // Comment out to connect as root instead. More info: https://aka.ms/vscode-remote/containers/non-root. &quot;remoteUser&quot;: &quot;vscode&quot; } . There are other available properties of this JSON file that we can add, for more info. . Preparing Container . We are done with our preparation, now we can tell VSCode to do its magic: . Press F1 and select the Remote-Containers: Open Folder in Container… command. | Selecting the project folder will trigger the container to build and start. | . Git Question . In the beginning, I wasn’t sure about the git configurations. How one might commit/push from a container. Then I found my answer here Working with Git?. . Conclusion . The experience was quite good for me, and I enjoyed working on this. In my opinion, this will help team members to not worry about setting up the development environment on their workstation. In a project, different team members use different OS on their workstations. Sometimes it becomes difficult to work with identical system configurations. This container based development might minimize such difficulties. . Finally, to get started with, I will suggest to clone and run vscode-remote-try-python. . Reference . Using Visual Studio Code from a docker image locally or remotely via VS Online . | VS Code Remote / GitHub Codespaces Container Definitions . | .",
            "url": "https://jabertuhin.github.io/jabers-blog/python/vscode/docker/english/2022/02/01/vscode-dev-container.html",
            "relUrl": "/python/vscode/docker/english/2022/02/01/vscode-dev-container.html",
            "date": " • Feb 1, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "স্ট্র্যাটিজি প্যাটার্ন (Strategy Pattern)",
            "content": "ডিজাইন প্যাটার্নের গুরুত্ব আমরা সকলেই কমবেশি জানি। সফটওয়্যার ডেভলপমেন্টের ক্ষেত্রে ডিজাইন প্যাটার্নগুলো জানা থাকলে আমাদের বিভিন্ন প্রবলেম সঠিক ডিজাইন মেইনটেইন করে সলভ করা সহজ হয়ে যাবে। এই ব্লগ পোস্টে আমরা এরই লক্ষ্যে “স্ট্র্যাটেজি প্যাটার্ন” সম্পর্কে জানতে চেষ্টা করবো। . প্রথমে naive এপ্রোচে একটা সলিউশন দাঁড় করানোর চেষ্টা করবো। পরবর্তীতে স্ট্র্যাটেজি প্যাটার্নকে ব্যবহার করে কিভাবে আমরা সেটাকে আরও ভালোভাবে ডিজাইন করতে পারি সেটা দেখবো। . প্রবলেম . আমরা ছোট একটা ভিডিও গেমের কথা চিন্তা করি - ক্রিকেটের একটা গেম হবে, যেখানে বিভিন্ন দেশের বিভিন্ন খেলোয়াড় থাকবে। এখন এই খেলোয়াড়দের কথা মাথায় রেখে আসুন আমরা কিছু ক্লাস ডিজাইন করি। . সমাধান . :arrow_right: সাধারণ পন্থায় . প্রথমে OOP এর কনসেপ্ট ধরে যদি চিন্তা করি - আমরা Player নামের একটা ইন্টার্ফেস তৈরি করতে পারি। যার bat() এবং bowl() নামের দুইটা মেথডকে ইমপ্লিমেন্ট করতে হবে। Player ক্লাসটা সেক্ষেত্রে নিম্নরূপ হবে :point_down: . (:hash: এখানে একটু বলে রাখা ভালো, পাইথনের ইন্টার্ফেস তৈরি পদ্ধতি অন্য স্ট্যাটিক টাইপড ল্যাঙ্গুয়েজ থেকে বেশ আলাদা। ) . from abc import ABC, abstractmethod class Player(ABC): def __init__(self, name: str, country: str): self.name = name self.country = country @abstractmethod def bat(self) -&gt; None: raise NotImplementedError @abstractmethod def bowl(self) -&gt; None: raise NotImplementedError def __str__(self) -&gt; str: return f&quot;My name is {self.name}. I&#39;m from {self.country}.&quot; . এখন এই Player ইন্টার্ফেসকে ব্যবহার করে আমি আমাদের ওপেনার তামিম ইকবাল খান-এর একটা ক্লাস যদি তৈরি করতে চাই। সেই ক্লাসটি হবে নিম্নরূপ :point_down: . class Tamim(Player): def __init__(self, name: str, country: str): super().__init__(name, country) def bat(self) -&gt; None: &quot;&quot;&quot;Implementation of Tamim&#39;s batting.&quot;&quot;&quot; def bowl(self) -&gt; None: &quot;&quot;&quot;Implementation of Tamim&#39;s bowling.&quot;&quot;&quot; . একজন ওপেনিং ব্যাটসম্যানের পরে এখন আমরা একজন বোলার, মুস্তাফিজুর রহমানের ক্লাস অনুরূপভাবে তৈরি করতে পারি। . class Mustafizur(Player): def __init__(self, name: str, country: str): super().__init__(name, country) def bat(self) -&gt; None: &quot;&quot;&quot;Implementation for Mustafizur&#39;s batting.&quot;&quot;&quot; def bowl(self) -&gt; None: &quot;&quot;&quot;Implementation for Mustafizur&#39;s bowling.&quot;&quot;&quot; . এইক্ষেত্রে আমরা যদি তামিম এবং মুস্তাফিজুরের অব্জেক্ট তৈরি করতে চাই, তা খুব সহজেই আমরা করতে পারবো নিম্নোক্তভাবে :point_down: . Tamim = Tamim(name=&quot;Tamim Iqbal&quot;, country=&quot;Bangladesh&quot;) Mustafizur = Mustafizur(name=&quot;Mustafizur Rahman&quot;, country=&quot;Bangladesh&quot;) . আপাত দৃষ্টিতে সব ঠিক মনে হচ্ছে। তামিমের জন্য আলাদা একটা ক্লাস ডিজাইন করে নিয়েছি, মুস্তাফিজের জন্যও আলাদা ক্লাস করে নিয়েছি। . এখন আমরা যদি বাংলাদেশ জাতীয় দলের অন্যান্য খেলোয়াড়দের ক্লাস তৈরি করতে চাই? এরপর ভারতের খেলোয়াড়দের? . প্রত্যেক খেলোয়াড়ের জন্যই তাহলে আমাকে আলাদা করে একটা ক্লাস তৈরি করতে হবে এবং সেই ক্লাসে bat() ও bowl() দুইটা মেথডকে প্রতিবার ইমপ্লিমেন্টও করতে হবে। এখন যদি একটু খেয়াল করি- তামিম, সাকিব, সৌম্য এরা প্রত্যেকেই বামহাতি ব্যাটসম্যান। সুতরাং, প্রত্যেক বামহাতি প্লেয়ারের জন্যও আমি বারবার bat() মেথড একইভাবে ইমপ্লিমেন্ট করছি। এবার মুস্তাফিজ বামহাতি ব্যাটসম্যান হলেও তাকে আমরা ঠিক ব্যাটসম্যান ক্যাটাগরিতে ফেলবো না। তার ক্ষেত্রে ব্যাটিং করার ইমপ্লিমেন্টেশন আলাদা হওয়া উচিত। . আমাদের বর্তমান ডিজাইন অনুযায়ী ব্যাটিং, বোলিং এর ইমপ্লিমেন্টেশন একেকটা ক্লাসের অর্থাৎ একেকজন খেলোয়াড়ের সাথে কাপল্ড(coupled) হয়ে যাচ্ছে, যাকে পরবর্তীতে আমরা পুনর্বার ব্যবহারও করতে পারছি না। . :arrow_right: Strategy Pattern ব্যবহারের মাধ্যমে . সামনে যাওয়ার পূর্বে আমাদেরকে দুটো কন্সেপ্টের সাথে পরিচিত থাকতে হবে। কনসেপ্টগুলো হলো - . :one: Composition over Inheritence . :two: Dependency injection . এগুলোর সাহায্য নিয়ে আমরা Strategy Pattern প্রয়োগ করে উপরের সমস্যাগুলো থেকে মুক্তি পেতে পারি। . আমরা এখন IBattingStyle ও IBowlingStyle এ দু’টো নতুন ইন্টার্ফেস নিয়ে আসছি। এই ইন্টার্ফেসগুলো ব্যবহার করে আমরা আমাদের পুর্বের Player ক্লাসকে নতুন করে ডিফাইন করবো। . from abc import ABC, abstractmethod class IBattingStyle(ABC): @abstractmethod def bat(self) -&gt; None: raise NotImplementedError class IBowlingStyle(ABC): @abstractmethod def bowl(self) -&gt; None: raise NotImplementedError . এখন আমরা আমাদের নতুন Player ক্লাসটা যদি লক্ষ্য করি :point_down: . class Player: def __init__(self, name: str, country: str, batting_style: IBattingStyle, bowling_style: IBowlingStyle): self.name = name self.country = country self.batting_style = batting_style self.bowling_style = bowling_style def bat(self) -&gt; None: self.batting_style.bat() def bowl(self) -&gt; None: self.bowling_style.bowl() def __str__(self) -&gt; str: return f&quot;My name is {self.name}. I&#39;m from {self.country}.&quot; . Player ক্লাসটার কাজ বদলায় নি, কিন্তু চেহারা বদলে গেছে। আমাদের ক্লাস এখন __init__ এ দু’টোর বদলে মোট ৪ টা আর্গুমেন্ট এক্সপেক্ট করছে। এখানে আমরা প্রতিটা খেলোয়াড়ের ব্যাটিং স্টাইল, বোলিং স্টাইল সেই খেলোয়াড়ের অব্জেক্ট তৈরি করার সময় দিয়ে দিতে পারবো। আর Player ক্লাসের bat() ও bowl() মেথড যাদের পুর্বে ইমপ্লিমেন্ট করতে হতো, এখন সেই মেথডগুলো শুধু batting_style ও bowling_style অবজেক্টের ইমপ্লিমেন্টেড মেথডকে কল করবে । এখানে Player ক্লাসকে কোন নির্দিষ্ট ব্যাটিং, বোলিং স্টাইলের ইমপ্লিমেন্টেশনের বিস্তারিত জানতে হচ্ছে না। শুধু নির্দিষ্ট একটা কাজ করার জন্য ইন্টার্ফেসের কোন মেথডকে কল করতে হবে, সেটা জানলেই হচ্ছে। . IBattingStyle, IBowlingStyle এর কি ধরনের ইমপ্লিমেন্টেশন হতে পারে যদি একটু দেখে নিই, তাহলে আমাদের পুরো জিনিসটা বুঝতে হয়তো আরেকটু সুবিধা হবে। . Implementations of IBattingStyle . class LeftHandBatting(IBattingStyle): def bat(self) -&gt; None: &quot;&quot;&quot;Implementation for Left-hand Batting.&quot;&quot;&quot; class RightHandBatting(IBattingStyle): def bat(self) -&gt; None: &quot;&quot;&quot;Implementation for Right-hand Batting.&quot;&quot;&quot; . এখানে :point_up_2: আমাদের প্রয়োজন হলে LeftHandAggresiveBatting একটা ইমপ্লিমেন্টেশনও যোগ করতে পারি। . Implementations of IBowlingStyle . class LeftHandFastBowling(IBowlingStyle): def bowl(self) -&gt; None: &quot;&quot;&quot;Implementation for Left-hand fast bowler.&quot;&quot;&quot; class RightHandFastBowling(IBowlingStyle): def bowl(self) -&gt; None: &quot;&quot;&quot;Implementation for Right-hand fast bowler.&quot;&quot;&quot; . আর :point_up_2: এখানে তো আমাদের অবশ্যই LeftArmOffBreakBowling, RightArmOffBreakBowling ইমপ্লিমেন্টেশনগুলোর কথা চিন্তা করতেই হবে। . আমরা পুর্বে যে তামিম, মুস্তাফিজুরের অবজেক্ট তৈরি করেছিলাম, তা বর্তমান ডিজাইনের সাপেক্ষে কেমন হবে তা দেখে নেয়া যাক :point_down: . # For the sake of the example, assume Tamim is Left-hand fast bowler. Tamim = Player(name=&quot;Tamim Iqbal&quot;, country=&quot;Bangladesh&quot;, batting_style=LeftHandBatting(), bowling_style=LeftHandFastBowling()) Mustafizur = Player(name=&quot;Mustafizur Rahman&quot;, country=&quot;Bangladesh&quot;, batting_style=LeftHandBatting(), bowling_style=LeftHandFastBowling()) . এখন আমরা চাইলেই খুব সহজে সাকিব আল হাসান, বিরাট কোহলির মতও খেলোয়াড়দের অবজেক্ট তৈরি করে ফেলতে পারবো। যার জন্য Player ক্লাসে কোন ধরনের পরিবর্তন আসবে না। বিরাট কোহলি এর জন্য শুধু নতুন RightHandMediumFastBowling এর ইমপ্লিমেন্টেশন লাগবে আমাদের, আর RightHandBatting এর ইমপ্লিমেন্টেশন আমাদের কাছে ইতিমধ্যেই আছে। এরপর শুধু অবজেক্ট তৈরি করার সময় তার নাম, দেশের নাম দিয়ে দিলেই হয়ে যাবে। . অনুশীলনের জন্য আপনি আরও কিছু খেলোয়াড়ের অবজেক্ট তৈরি করার কথা চিন্তা করতে পারেন। কিভাবে করবেন, আর তাদের জন্য কি লাগতে পারে। . এই যে আমরা আমাদের প্লেয়ারদের ব্যাটিং, বোলিং করার ধরনকে আলাদা রাখছি এবং তা রানটাইমে বলে দিচ্ছি - এর মাধ্যমেই আমরা Strategy Design Pattern-কে ফলো করছি। এখন যদি Strategy Design Pattern এর কিতাবি সংজ্ঞা দেখে নিই . The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it. . এই সংজ্ঞা এর সাথে আমাদের উপরের উদাহরণটা মিলিয়ে নিলেই বুঝতে পারবেন আমরা কিভাবে Strategy Design Pattern কে ফলো করেছি। ডিজাইন প্যাটার্নের ৩ টি ধরন আছে, এই Strategy Design Pattern তার মধ্যে Behavioral Patterns এর মধ্যে পড়ে। . References . RefactoringGuru: Strategy Pattern . | Keep it Simple with the Strategy Design Pattern . | Head First Design Patterns . | Python Dependency Injection . | .",
            "url": "https://jabertuhin.github.io/jabers-blog/design%20pattern/python/bangla/2021/07/03/strategy-pattern.html",
            "relUrl": "/design%20pattern/python/bangla/2021/07/03/strategy-pattern.html",
            "date": " • Jul 3, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "পাইথনে প্রি-কমিট হুকের সাথে পরিচিতি(Introduction to Pre-commit Hook in Python)",
            "content": "প্রি-কমিট হুকের সাথে পরিচিতি Vladimir Iglovikov এর ব্লগ Nine simple steps for better-looking python code পোস্টের মাধ্যমে। আমার কাছে খুবই ইন্টারেস্টিং কনসেপ্ট মনে হয়েছে, তাই এই ব্যাপারে একটা ব্লগ লিখা। পাইথন প্রজেক্টের ক্ষেত্রে কিভাবে আমরা pre-commit hook ব্যবহার করতে পারি, তা নিয়েই এই ব্লগ পোস্ট। . কেন pre-commit hook প্রয়োজন . আমরা যখন একটা প্রজেক্টে কাজ করি- তখন সেখানে কয়েকজন ডেভলপার থাকে, একজন অন্যজনের কোড রিভিউ করে। পুল-রিকুয়েস্ট রিভিউ করার সময় আমাদের মূল ফোকাস যেন কোডের লজিক, ডিজাইন ইত্যাদি গুরুত্ব পূর্ণ বিষয়গুলোতে বেশি থাকে। আমার কলিগের পুল-রিকুয়েস্ট যেন একটা এক্সট্রা স্পেস কিংবা এক্সট্রা নিউ লাইনের জন্য ঝুলে না থাকে। ল্যাঙ্গুয়েজ স্পেসিফিক বেস্ট প্র্যাকটিস যেন আমরা আরেকটা টুলসের মাধ্যমে নিশ্চিত করতে পারি। . তাছাড়া ডেভলপাররাও বিভিন্ন সময় ভুল করে- সেই ভুল হতে পারে ডেভলপমেন্ট/মাস্টার ব্রাঞ্চে ভুল করে কমিট করা, কোন একটা লার্জ ফাইল গিট ইগ্নোর না করায় তা কমিট হয়ে যাওয়া, গিট পুশ করার আগে ইউনিট টেস্টগুলো সব পাস হচ্ছে নাকি তা চেক না করেই পুল-রিকুয়েস্ট ক্রিয়েট করে ফেলা। . এইসব বিভিন্ন ধরনের চেকিং আমরা চাইলে আমাদের কমিট করার আগে করতে পারি। সেটার জন্যই আমরা আজকে একটা পাইথন প্রজেক্টে pre-commit hook কিভাবে ব্যবহার করতে হয় তা দেখবো। . pre-commit প্যাকেজ ইন্সটলেশন . আমাদের প্রজেক্টে প্রথমে pre-commit পাইথন প্যাকেজ ইন্সটল করতে হবে, এবং এই প্যাকেজ ব্যবহার করে আমরা pre-commit ও pre-push - git hooks ইন্সটল করবো। . pip install pre-commit pre-commit install --hook-type pre-commit --hook-type pre-push . এই pre-commit প্যাকেজকে আমরা requirements.dev.text তেও এড করে দিবো, কারণ এই প্যাকেজটা শুধু ডেভলপমেন্টের সময় লাগবে। . .pre-commit-config.yaml -এর মাধ্যমে কনফিগারেশন . এখন আসি, কিভাবে আমাদের pre-commit hook কে কনফিগার করবো। .pre-commit-config.yaml ফাইলে আমরা আমাদের প্রয়োজন অনুযায়ী কনফিগারশন করবো, আর সেটিকে প্রজেক্ট রুটে রাখবো। নিম্নে আমার একটা টয় প্রজেক্টের .pre-commit-config.yaml ফাইল দেয়া হলো - . repos: - repo: https://github.com/pre-commit/pre-commit-hooks rev: v3.4.0 hooks: - id: trailing-whitespace - id: check-added-large-files - id: no-commit-to-branch - id: check-yaml - repo: https://gitlab.com/pycqa/flake8 rev: 3.8.4 hooks: - id: flake8 stages: [commit] - repo: https://github.com/pre-commit/mirrors-mypy rev: v0.812 hooks: - id: mypy additional_dependencies: [tokenize-rt==3.2.0] stages: [commit] - repo: local hooks: - id: tests name: run tests entry: pytest -v language: system always_run: true types: [python] stages: [push] . pre-commit-hooks . প্রথম যে রিপোটা আমরা ব্যবহার করছি তা হলো pre-commit-hooks, এ আমাদেরকে বেশকিছু চেকিং এবং ফিক্সিং আউট-অফ-দা-বক্স সাপোর্ট দেয়। যেমন, আমাদের ফাইলে খেয়াল করলে hooks এর নিচে দেখতে পাচ্ছি প্রথম id হলো trailing-whitespace , যেটা আমার কোডের প্রতি লাইনের শেষের এক্সট্রা স্পেসগুলি রিমুভ করে দিবে এবং সেক্ষেত্রে আপনার কমিট ফেইল করবে। আমাদেরকে তখন নতুন করে স্পেসিফিক ফাইলকে স্টেজ করে কমিট করতে হবে, কারণ প্রয়োজনীয় চেঞ্জ আমাকে করে দিয়েছি এই hook । এরপরের আইডি হলো- check-added-large-files, এর ডিফল্ট ভ্যালু ৫০০ KB দেয়া। এর চেয়ে বড় ফাইল আপনি কমিট করতে চাইলে, সেটা এই চেকিং এ ধরা পড়বে এবং আপনি কমিট করতে পারবেন না। no-commit-to-branch এটা দিয়ে আমি নিশ্চিত করতে পারবো কেউ যেন সরাসরি মাস্টার ব্রাঞ্চে কমিট করতে না পারে(আর্গুমেন্ট দিয়ে আমরা অন্য ব্রাঞ্চও কনফিগার করতে পারবো।), check-yaml আইডি দিয়ে আমরা yaml ফাইলের ফরম্যাটিং চেক করতে পারবো। আরও জানার জন্য গিটহাব রিপো দেখুন - pre-commit-hooks . flake8 . এরপরে পাইথনে স্টাইল গাইড ফলো করার জন্য আমরা flake8 রিপো ব্যবহার করবো, যে পাইথন ফাইলগুলো আমি কমিট করতে চাচ্ছি সেগুলো সকল স্টাইলিং গাইড মেইনটেইন করছে কি-না, না করলে কোন ফাইলের কোথায় ইস্যু সেটা বলে দিবে। আর এখানে আমরা stages এ বলে দিচ্ছি - commit, যেন শুধু git commit এর সময়ই এই চেকিং টা হয়। flake8 সম্পর্কে জানার জন্য তাদের গিটহাব রিপো দেখুন - flake8 - Github . mypy . তৃতীয়ত আসছে mypy, পাইথনের টাইপ চেকিং এর জন্য। এই প্যাকেজের নিজস্ব কোন ডিপেন্ডেন্সি থাকলে সেটাও আমরা উল্লেখ করে দিতে পারি additional_dependencies এর মাধ্যমে। mypy সম্পর্কে জানার জন্য তাদের ডকুমেন্টেশন পেজ দেখুন - Mypy Introduction . tests . সর্বশেষে আসছে, ইউনিট টেস্ট রান করা। আমি আমার ইউনিট টেস্ট রান করতে চাই git push করার সময়ে, সে জন্য এখানে আমার stages এ শুধু push বলা আছে। আর pytest এর মাধ্যমে আমার টেস্ট রান করতে বলছি entry তে। always_run ব্যবহার করে আমরা বলে দিচ্ছি যেন সবসময় push করার আগে টেস্ট ফাইলগুলো রান করে। . উদাহরণ . আমি আমার প্রজেক্টের requirements.txt থেকে একটা প্যাকেজ রিমুভ করে দিয়ে, একটা কমিট করি। যেহেতু এটা পাইথন ফাইল না, পাইথন স্পেসিফিক হুকগুলো এখানে রান করে নি। . পরবর্তীতে আমি এই চেঞ্জ যখন push করি তখন কমিট স্পেসিফিক চেকিং গুলো হয় নি, আর push এর সময় টেস্ট রান করতে বলেছিলাম সেই টেস্ট রান হয়েছে। . CI পাইপলাইনে প্রি-কমিট হুক চেকিং . Bitbucket Pipeline Example . Bitbucket পাইপলাইনে মাল্টিপল স্টেপ প্যারালালি রান করা যায়। এর ফলে CI রান করার ওয়েটিং টাইমটা কমিয়ে ফেলা যায়। . image: python:3.8 definitions: steps: - step: &amp;coverage name: Running Test size: 2x caches: - pip script: - pip install -r requirements.dev.txt - pytest - step: &amp;pre_commit name: Pre-Commit Hook Checking caches: - pip script: - pip install pre-commit==2.17.0 - pre-commit run --all-files pipelines: branches: development: - parallel: - step: *coverage - step: *pre_commit pull-requests: &#39;**&#39;: - parallel: - step: *coverage - step: *pre_commit . Github Action Pipeline Example: . name: Continuous Integration on: push: branches: - development pull_request: branches: - &quot;**&quot; jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Set up Python uses: actions/setup-python@v2 with: python-version: &#39;3.8&#39; - name: Install dependencies run: | python -m pip install --upgrade pip make dev_setup - name: Test with pytest run: | make test - name: Pre-Commit Hook Checking run: | pre-commit run --all-files . Resources . Automate Python workflow using pre-commits: black and flake8 . | pre-commit-hooks . | Supported hooks . | Customizing Git - Git Hooks . | pre-commit . | My unpopular opinion about black code formatter . | [Bitbucket] Set up or run parallel steps . | . UPDATE Log . [27th January, 2022] Add CI pipeline example for Bitbucket and Github Action. .",
            "url": "https://jabertuhin.github.io/jabers-blog/pre-commit%20hook/git/python/bangla/2021/03/13/pre-commit-hook-in-python.html",
            "relUrl": "/pre-commit%20hook/git/python/bangla/2021/03/13/pre-commit-hook-in-python.html",
            "date": " • Mar 13, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "মেশিন লার্নিং ইন্টার্ভিউ প্রিপারেশন (Machine Learning Interview Preparation)",
            "content": "বাংলাদেশে ২/৩ বছর আগেও মেশিন লার্নিং রিলেটেড জব পোস্ট খুব একটা চোখে পড়তো না। ইদানিংকালে ইন্টার্ন পজিশনে, জুনিওর পজিশনে কিংবা সিনিওর পজিশনেও মেশিন লার্নিং ইঞ্জিনিয়ার/ডাটা সায়েন্টিস্ট রোলের জন্য চাকরির বিজ্ঞপ্তি দিতে দেখা যাচ্ছে বিভিন্ন কোম্পানিকে। . বর্তমান সময়ে CS গ্র্যাড কিংবা CS গ্র্যাড ছাড়াও অনেকেরই ফাইনাল ইয়ার থিসিস টপিক মেশিন লার্নিং ওরিয়েন্টেড হয়ে থাকে। আর হালের ক্রেজ হিসেবেও মেশিন লার্নিং-কে বিবেচনা করতে পারি আমরা। Software Engineer রোলের জন্য কিভাবে নিজেকে প্রস্তুত করতে হয়, সিভি কিভাবে তৈরি করতে হয় আর ইন্টার্ভিউ প্রিপারেশন কিভাবে নিতে হয় তা নিয়ে যথেষ্ট লিখা থাকলেও, এই নতুন মেশিন লার্নিং রিলেটেড জব পজিশনের জন্য যথেষ্ট ভালো রিসোর্স পাওয়া দুষ্কর। এই লিখাতে সেই জায়গার শূন্যস্থান পূরণের একটা চেষ্টা করবো মাত্র(বাংলাদেশের কন্টেক্সটে)। . মেশিন লার্নিং . মেশিন লার্নিং রিলেটেড পোস্টে অবশ্যই মেশিন লার্নিং নিয়ে প্রশ্ন করা হবে। মেশিন লার্নিং এর মতো বড় ডোমেইনের ক্ষেত্রে সে প্রশ্নগুলি কোথা থেকে আসতে পারে, তা জেনে ইন্টার্ভিউ এর আগে নিজেকে প্রস্তুত করা একটু কঠিন কাজ হতে পারে। এক্ষেত্রে সাজেশন হলোঃ . আপনার যেখানে ইন্টার্ভিউ, তারা কি নিয়ে কাজ করে তা একটু ঘেঁটে দেখেন। ধরেন, আপনি ব্যাংকিং অথবা ফাইনান্সিয়াল সেক্টরে মেশিন লার্নিং ইঞ্জিনিয়ার রোলের জন্য এপ্লাই করে ইন্টার্ভিউ এর জন্য কল পেয়েছেন। সেখানে ট্যাবুলার ডাটা নিয়ে কাজ করার সম্ভাবনা বেশি। আর সেক্ষেত্রে ট্রেডিশনাল মেশিন লার্নিং (স্ট্যাটিস্টিক্যাল লার্নিং ) এর গুরুত্ব হয়তো বেশি হবে। Logistic Regression, Linear Regression , Tree Based Algorithms - এর খুঁটিনাটি দেখে গেলে হয়তো সুবিধা পাবেন( SQL নিয়ে পূর্ব অভিজ্ঞতা থাকলে সেটাও এখানে কাজে দিতে পারে )। আবার যারা কম্পিউটার ভিসন নিয়ে কাজ করেন তাদের কোম্পানিতে ইন্টার্ভিউ দেয়ার সময় CNN এর টুকিটাকি সম্পর্কে জানা থাকা ভালো। তবে এখানে বলে রাখা ভালো যে, আপনি হয়তো CNN নিয়ে আগে কাজ করেন নি, সেটা ইন্টার্ভিউতে যাওয়ার আগে দেখে ভারি ভারি শব্দ ইন্টার্ভিউয়ারকে শোনাতে যাবেন না, হিতের বিপরীত হতে পারে। | (এই পয়েন্ট না বললেও চলতো, তাও লিখে রাখছি ) নেট ঘেঁটে দেখতে পারেন আপনি যে কোম্পানিতে ইন্টার্ভিউ দিতে যাচ্ছেন সেই কোম্পানিতে ইন্টার্ভিউ দেয়ার অভিজ্ঞতা কেউ ব্লগ আকারে পাবলিশ করেছে কিনা। সেখান থেকে ভালো একটা ধারণা পাবেন। | আরেকটা খুব গুরুত্বপূর্ণ পয়েন্ট হলো - আপনি সিভিতে নিজের কাজ সম্পর্কে যা লিখেছেন তা সম্পর্কে স্পষ্ট ধারণা রাখা। আপনি বর্তমান কর্মক্ষেত্রে যা নিয়ে কাজ করছেন, নিজের অবসর সময়ে বানানো যে প্রজেক্ট সম্পর্কে লিখেছেন, নিজের ভার্সিটির যে প্রজেক্ট/থিসিস/রিসার্চ পেপারের কথা সিভিতে উল্লেখ করেছেন, সেগুলো ইন্টার্ভিউতে যাওয়ার আগে আরেকবার দেখে যাওয়া। ঐসব কাজের জন্যই হয়তো আপনাকে ইন্টার্ভিউতে ডাকা হয়েছে, অথচ ইন্টার্ভিউতে সে সম্পর্কে যদি আপনি বিস্তারিত না বলতে পারেন সেটা নিজের কাছেই হয়তো খারাপ লাগবে। | . এতো গেলো কি কি বিষয় দেখা যেতে পারে, কিন্তু কতটুকু দেখবেন? আপনি যদি মেশিন লার্নিং রিসার্চার পজিশনে এপ্লাই করে থাকেন তাহলে অবশ্যই থিওরেটিকাল প্রশ্নের জন্য প্রস্তুত থাকতে হবে। বাংলাদেশে ভার্সিটিগুলোর RA পজিশন ছাড়া আর কোন কোম্পানি শুধুমাত্র RnD এর জন্য জব সার্কুলার ছেড়েছে এমন চোখে পড়েনি। আর মেশিন লার্নিং ইঞ্জিনিয়ার/ রিসার্চার , ডাটা সায়েন্টিস্ট/ এনালিস্ট ইত্যাদি গাল ভারী করা নামগুলোর পার্থক্যটা জানা থাকলেও আপনার হয়তো সুবিধা হবে, কোন জবের সাথে আপনার ইন্টারেস্ট ম্যাচ করে তা বুঝে এপ্লাই করার জন্য। . মেশিন লার্নিং ইঞ্জিনিয়ারিং রোলের জন্য হয়তো আপনার বিভিন্ন মেশিন লার্নিং এলগোরিদমের নাড়ীনক্ষত্র (ম্যাথেমেটিকাল ইকুয়েশন, প্রুফ) জানা থাকা আবশ্যিক না, তবে জানলে ক্ষতি নেই। আবার তাই বলে শুধু হাই-লেভেল এপিয়াই কল করে কাজ করার যোগ্যতা থাকলেই চলবে তা মনে করার কারণ নেই। মেশিন লার্নিং এর বেসিক যে কনসেপ্টগুলো, যেগুলো যেকোন অনলাইন কোর্সের প্রথমেই কভার করে সে সম্পর্কে জানা থাকতে হবে(যেমনঃ ওভার ফিটিং, আন্ডার ফিটিং, ডাটা ট্রেইন/ভ্যালিডেশন/টেস্ট সেটে ভাগ করা, লস ফাংশনের কাজ, ব্যাক প্রোপাগেশন, ভ্যানিশিং গ্র্যাডিয়েন্ট, এক্সপ্লোডিং গ্র্যাডিয়েন্ট ইত্যাদি)। আর যেসব মেশিন লার্নিং এল্গো, আর্কিটেকচার নিয়ে কাজ করেছেন সেগুলোর সম্পর্কে intuitive (মানে কোনটা কখন ভালো কাজ করে, কেন করে) ধারনা থাকা অত্যন্ত জরুরি। তা নাহলে কোন প্রবলেম সল্ভ করার জন্য কখন কোনটা ব্যবহার করা উচিত তা বুঝবেন না। . সফটওয়্যার ইঞ্জিনিয়ারিং . এই লিখাটা মূলত মেশিন লার্নিং ইঞ্জিনিয়ারদের কথা মাথায় রেখেই লিখা। সেক্ষেত্রে সফটওয়্যার ইঞ্জিনিয়ারিং একটা গুরুত্বপূর্ণ অংশ। আগেই বলেছি মেশিন লার্নিং নিয়ে শুধু রিসার্চ করার মতো স্কোপ বাংলাদেশে কম, আর বাহিরেও স্টার্টাপগুলোতে মেশিন লার্নিং নিয়ে যারা কাজ করে তাদেরকে মডেল তৈরি করার কাজও করতে হয়, এবং সেই মডেলকে ডিপ্লয় দেয়ার কাজও করতে হয়। আর ডিপ্লয় করার পরবর্তীতে সেই মডেলের পার্ফর্মেন্স মনিটরিং করে তাকে রিট্রেইন করার কাজটুকুও করতে হয়। এই সকল কাজের জন্য সফটওয়্যার ইঞ্জিনিয়ারিং রিলেটেড জ্ঞান থাকা অত্যন্ত জরুরি। . আপনি কোন পজিশনের জন্য এপ্লাই করছেন তার উপর নির্ভর করবে এইখানে আপনার কতটুকু দক্ষতা ইন্টার্ভিউয়ার চাচ্ছেন। জুনিওর পজিশনে বেসিক কিছু জিনিস জানা থাকলেই হবে, যেগুলো অন্যান্য সফটওয়্যার ইঞ্জিনিয়ারিং জবের জন্যও চাওয়া হয়ে থাকে। যেমনঃ OOP রিলেটেড জ্ঞান, REST API নিয়ে কাজ করার অভিজ্ঞতা, ইত্যাদি। . আপনি যদি মিড লেভেল কিংবা সিনিওর পজিশনের জন্য এপ্লাই করে থাকেন, সেক্ষেত্রে AWS অথবা অন্য কোন ক্লাউড প্লাটফর্মে কাজ করার অভিজ্ঞতা একটি বাড়তি চাওয়া হতে পারে। . প্রবলেম সল্ভিং . এর মাধ্যমে আসলে দেখা হয় আপনি কিভাবে একটা সমস্যাকে সমাধান করার চেষ্টা করছেন, আপনি যখন কোন একটা সমস্যা সমাধান করার চিন্তাটা ইন্টার্ভিউ বোর্ডে শেয়ার করবেন - সেই চিন্তা নিয়েও হয়তো আপনার সাথে ইন্টার্ভিউ বোর্ডের অন্য মানুষদের আলোচনা হবে। এর মাধ্যমে আপনারা উভয় পক্ষই বুঝতে পারবেন, আপনারা একসাথে কাজ করলে কেমন হতে পারে। . আপনি কি তাদের প্রশ্ন বুঝতে পারছেন? আপনি কি তাদের উল্লেখিত সমস্যা সম্পর্কে আরেকটু গভীরে চিন্তা করে কোন কর্নার কেস নিয়ে প্রশ্ন করছেন? আপনি হয়তো একটা সমাধান দিলেন সেই সমাধানের কোথাও অপ্টিমাইজেশনের সুযোগ আছে, সেটা বলার পরে কি আপনি সেটা নিয়ে চিন্তা করে সঠিক পথে এগুতে পারছেন? এমন টুকটাক জিনিসের মাধ্যমে আপনাকে বিচার করা তাদের জন্য সহজ হয়ে উঠে। . এর জন্য আপনি LeetCode, HackerRank, HackerEarth এর বিভিন্ন প্রবলেম সল্ভ করে নিজেকে তৈরি করতে পারেন। একই ধরনের সমস্যা অনেকগুলো সমাধান না করে, বিভিন্ন ধরনের সমস্যা কয়েকটা বুঝে সমাধান করা বেশি জরুরি। আর আপনি নিজের মতো করে সমাধান করার পরে ডিসকাশনে মানুষের সমাধানও গুলো পড়ে দেখতে পারেন, নিজের চিন্তায় কোথায় আর উন্নতির সুযোগ আছে জানার জন্য। উল্লেখ না করলেই নয়, আপনি যে সমাধান দিচ্ছেন তার টাইম কমপ্লেক্সিটি এবং স্পেস কমপ্লেক্সিটি নিয়েও আপনাকে প্রশ্ন করা হতে পারে। . বোনাস সাজেশন . আপনি এখন যেই পজিশনের চাকরিই খুঁজছেন না কেন, দেশের ভিতররের এবং বাহিরের সেই একই পজিশনের জব পোস্টগুলি ঘেঁটে দেখেন। সেই অনুযায়ী নিজেকে প্রস্তুত করুন। নিজেকে প্রস্তুত করার বারটা একটু উপরেই রাখুন। . | অন্যান্য অভিজ্ঞ মানুষের মতামত জানার জন্য, মেশিন লার্নিং কিংবা সফটও্যার ইঞ্জিনিয়ারিং রিলেটেড আপডেট, বেস্ট প্র্যাকটিসেস জানার জন্য LinkedIn , Twitter এ সব ফিল্ডের অভিজ্ঞ মানুষদের ফলো করা শুরু করুন। অনেক কিছু শিখতে পারবেন। . | আপনি যদি CS ব্যাকগ্রাউন্ডের কেউ না হয়ে থাকেন, কিন্তু মেশিন লার্নিং নিয়ে কাজ করতে আগ্রহী, সেক্ষেত্রে অনলাইন কোর্সের সহায়তায় কোর কম্পিউটার সায়েন্সের কোর্সগুলি করে ফেলতে পারেন(ডাটা স্ট্রাকচার, এলগোরিদম ইত্যাদি) . | . লিখাটা অনেক হাই-লেভেল ওভারভিউ হিসেবে চিন্তা করতে পারেন। প্রতিটা ভাগ নিয়ে আরও বিস্তারিত লিখার কিংবা কথা বলার সুযোগ আছে। তবে সেইগুলো নিয়ে আলোচনার লক্ষ্য এই ব্লগ পোস্ট নয় এবং তা নিয়ে লিখার পর্যাপ্ত অভিজ্ঞতাও এখনও অর্জন করি নি। তবে নিজে যতোটুকু পড়ে জেনেছি, কাজ করতে গিয়ে যতোটুকু অনুধাবন করেছি, তার প্রেক্ষিতে এই ব্লগ পোস্টটি লিখা। . রিসোর্সেসঃ . ইন্টার্ভিউ এক্সপেরিয়েন্স সম্পর্কে জানার জন্য . Tahanima’s Blog | . ইন্টার্ভিউ প্রিপারেশন কোর্স . Machine Learning Interview Preparation | Data Science Interview Prep | . সফটওয়্যার ইঞ্জিনিয়ারিং . TechTong Youtube Channel | . মেশিং লার্নিং সিস্টেম . Stanford MLSys Seminars | Full Stack Deep Learning | . মেশিং লার্নিং কনসেপ্ট(Practical) . Kaggle Courses | . ডাটা স্ট্রাকচার এন্ড এলগোরিদম . Intro to Data Structures and Algorithms | শাফায়েতের ব্লগ প্রোগ্রামিং ও অ্যালগরিদম টিউটোরিয়াল | .",
            "url": "https://jabertuhin.github.io/jabers-blog/interview%20preparation/machine%20learning/bangla/2021/03/06/mle-interview-preparation.html",
            "relUrl": "/interview%20preparation/machine%20learning/bangla/2021/03/06/mle-interview-preparation.html",
            "date": " • Mar 6, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "সিঙ্গেল রেস্পন্সিবিলিটি প্রিন্সিপল (Single Responsibility Principle)",
            "content": "অব্জেক্ট ওরিয়েন্টেড প্রোগ্রামিং নিয়ে যারা কাজ করেছেন এবং কোনদিন ডিজাইন প্রিন্সিপল বিষয়ে গুগল করেছেন - SOLID principles টার্মটার সাথে তারা কমবেশি সবাই পরিচিত। . অব্জেক্ট ওরিয়েন্টেড প্রোগ্রামিং এর ৫-টি গুরুত্বপূর্ণ ডিজাইন প্রিন্সিপলের প্রথম অক্ষর নিয়ে এই S.O.L.I.D. টার্মটির উদ্ভব হয়েছে। এইসব ডিজাইন প্রিন্সিপলগুলো একটি সফটওয়্যার ডিজাইনকে সহজে বুঝতে সাহায্য করে, সেটাকে রক্ষণাবেক্ষণে সাহায্য করে এবং পরবর্তীতে সফটওয়্যার-এর পরিধি বৃদ্ধিকে সহজ করে। সকল সফটওয়্যার ইঞ্জিনিয়ারের এইসব ডিজাইন প্রিন্সিপল সম্পর্কে ধারণা থাকা জরুরি। . আজকে আমরা এই S.O.L.I.D. -এর S নিয়ে আলোচনা করবো। . S = Single Responsibility Principle(SRP) . এই প্রিন্সিপলের মূল কথা হচ্ছে - “A class should have one, and only one, reason to change.” যেটাকে আরেকটু সহজবোধ্য করা যায় যদি বলি - একটি ক্লাস শুধুমাত্র একটি নির্দিষ্ট বিষয়েই কাজ করবে এবং সেই কাজের জন্যই শুধুমাত্র পরিবর্তিত হবে। এটি ক্লাসের মেথডের জন্যও সত্য, আবার একটি মডিউলের কথা বললে সেখানেও সত্য। . দেখুন, দৈনন্দিন জীবনে প্রতিনিয়ত আমরা এই প্রিন্সিপল মেনেই কিন্তু কাজ করছি। উদাহরণস্বরূপ, ইউনিভার্সিটিতে ভর্তি প্রক্রিয়ার কথা চিন্তা করতে পারি। আমরা রেজিস্ট্রার অফিস থেকে একটা ফর্ম তুলি এবং সেটা ফিলাপ করি। এরপরে ব্যাংকে নির্দিষ্ট পরিমাণ টাকা জমা দিয়ে রিসিপ্ট সংগ্রহ করি, মেডিকেল চেকাপ করিয়ে একটা এপ্রুভাল সংগ্রহ করি, আরো কোন বাড়তি কাজ থাকলে সেগুলো সম্পন্ন করে সকল কাগজ একসাথে আবার রেজিস্ট্রেশন অফিসে জমা দিই। মেডিকেল চেকের সময় কিন্তু ডাক্তার টাকা জমা নিচ্ছে না, কিংবা ব্যাংকে টাকা জমা দেয়ার সময় আমার হেলথ চেকাপের কাজটিও করে দিচ্ছে না। . উপরের উদাহরণের প্রত্যেকটি কাজ স্বতন্ত্র, শুধু রেজিস্ট্রার অফিস চেক করে প্রত্যেকটি কাজ সঠিকভাবে সম্পন্ন হয়েছি কি-না। প্রত্যেকে আলাদাভাবে কিভাবে কাজ করেছে সেটা কিন্তু আবার তার দেখার বিষয় না। . উপরের বাস্তবিক ঘটনা থেকে একধরনের আন্দাজ পাওয়ার কথা Single Responsibility বলতে কি বোঝায়। সেখানে একজনের কাজের ধরনে পরিবর্তন হলে অন্য আরেকজনের কাজে তা প্রভাব ফেলবে না। ভার্সিটি এখন যদি বিকাশের মাধ্যমে টাকা নেয়ার শুরু করে তবে কিন্তু শুধুমাত্র একটা জায়গায় পরিবর্তন হচ্ছে, বাকিসব আগের মতোই থাকছে। আমরা এই লিখা থেকে যা বুঝতে চাচ্ছি তার মূল উদ্দেশ্যই এখানে। যে যার যার মতো কাজ করলে একজনের পরিবর্তন অন্যজনকে প্রভাবিত করবে না। যা একটি ভালো সফটওয়্যারের বৈশিষ্ট্য হওয়া উচিত। . যেহেতু এখানে আমরা অব্জেক্ট ওরিয়েন্টেড প্রোগ্রামিং এর প্রিন্সিপল হিসেবে একে ব্যাখ্যা করতে চাচ্ছি, এবার তবে কোড দেখা যাক। (পাইথন প্রোগ্রামিং ল্যাঙ্গুয়েজ ব্যবহার করে কোডিং উদাহরণগুলো দেয়া হবে) . class Student: def __init__(self, name, id): self.name = name self.id = id def calculate_semester_fee(self): # calculate semester_fee return semester_fee def calculate_semester_cgpa(self): # calculate semester_cgpa if semester_cgpa &lt; 2.0: # send message to guardian return semester_cgpa . এখানে Stuednt - নামের একটি ক্লাস তৈরি করা হয়েছে। যেখানে স্বাভাবিকভাবেই Student এর নাম এবং আইডি ফিল্ড আছে(init মেথডে ইনিশিয়ালাইজেশনের কাজ হয়ে থাকে)। তাছাড়া আমরা আরো দু’টি মেথড দেখতে পাচ্ছি - . ১. calculate_semester_fee - যার কাজ সেমিস্টারের ফি ক্যালকুলেট করা, . ২. calculate_semester_cgpa - যার কাজ সেমিস্টারের CGPA ক্যালকুলেট করা। . Single Responsibility Principle এর মূলকথা এখানে কিভাবে ক্ষুন্ন হচ্ছে তা একটু দেখে নেয়া যাক। নিম্নোক্ত ব্যাখ্যা পড়ার আগে নিজে একবার চেষ্টা করে দেখুন, ভুলগুলো বের করতে পারেন কি-না কিংবা ভুলগুলো নিম্নোক্ত ব্যাখ্যার সাথে মিলে কি-না। একটা Student ক্লাসে যা কিছু থাকবে তার প্রতিটি-ই Student কেন্দ্রিক হতে হবে। আর এখানে যদি কোন পরিবর্তন আনতেই হয় সেটাকে অবশ্যই Student সম্বন্ধীয় হতে হবে। . প্রথমে, calculate_semester_fee মেথডের কথায় আসি। একজন Student প্রতি সেমিস্টারে কি পরিমাণ ফি প্রদান করবে সেটা সেই Student এর দেখার বিষয় না। এটা ইউনিভার্সিটির কর্তৃপক্ষের দেখার বিষয়। . একটা নির্দিষ্ট সময় পর পর ইউনিভার্সিটিগুলোর সেমিস্টার ফি-র পরিবর্তন হয়। তাছাড়াও নানা কারণে যেমন মাঝে একবার ভ্যাট দিতে হলো, এমন কোন কারণে সেমিস্টার ফি ক্যালকুলেশনের পরিবর্তন ঘটতে পারে। আমার বর্তমান Student ক্লাসের ডিজাইন অনুযায়ী, সেমিস্টার ফি-র ক্যালকুলেশন পরিবর্তনের জন্য আমার Student ক্লাসের calculate_semester_fee মেথডের ভিতরে পরিবর্তন করতে হচ্ছে। যেটা Student ক্লাসের সাথে সরাসরি সম্পর্কিত না। . দ্বিতীয়ত, calculate_semester_cgpa মেথডে একজন Student এর এক সেমিস্টারের সিজিপিএ হিসেব করা হচ্ছে। সেই সিজিপিএ যদি আবার ২ এর থেকে কম হয় সেক্ষেত্রে অভিবাবকের কাছে ম্যাসেজ চলে যাবে। একটা ক্লাস দিয়ে সাধারণত আমরা কোনকিছুকে উপস্থাপন করি, উপস্থাপনায় কি ছাত্র-ছাত্রীর সিজিপিএ কিভাবে ক্যালকুলেট করা হচ্ছে তা থাকা উচিত? তার উপর সেই সিজিপিএ একটা নির্দিষ্ট সংখ্যার নিচে গেলে কি করতে হবে তাও বলে দেয়া হচ্ছে। ইউনিভার্সিটি যদি কোনদিন সিদ্ধান্ত নেয় ২ এর বদলে ১.৫ এর নিচে সিজিপিএ হলে স্তুডেন্টের অভিবাবকের কাছে ম্যাসেজ চলে যাবে কিংবা অভিভাবকের মোবাইলে ম্যাসেজ যাওয়ার পরিবর্তে মেইল যাবে এসবক্ষেত্রে আমাকে কোডে পরিবর্তন করতে হচ্ছে, যেটা কাম্য নয়। . Student ক্লাসে আমার এমন দু’টি মেথড আছে যারা আমার ক্লাসের সাথে সরাসরি সম্পর্কিত না এবং তাদের জন্য আমার ক্লাসের কোডকে বারবার পরিবর্তন করতে হচ্ছে। এখানেই আমি Single Responsibility Principle মান্য করি নি। . তবে সমাধান কি? উপরোক্ত ক্লাসকে ভেঙ্গে আমরা নতুন তিনটি ক্লাস তৈরি করতে পারি, যার প্রত্যেকে নির্দিষ্ট কাজের জন্য দায়ী থাকবে। . class Student: def __init__(self, name, id): self.name = name self.id = id class SemesterFeeCalculationService: def calculate_semester_fee(self, course_taken): # calculate semester_fee return semester_fee class CgpaCalculationService: def calculate_semester_cgpa(self, student, minimum_cgpa): # calculate semester_cgpa if semester_cgpa &lt; minimum_cgpa: # send message to guardian return semester_cgpa . এখন আমি যদি Student ক্লাসে নতুন ফিল্ড যোগ করতে চাই(যেমনঃ address) তবে Student ক্লাসকে, সেমিস্টার ফি ক্যালকুলেশনে পরিবর্তন করতে চাইলে SemesterFeeCalculationService ক্লাসকে কিংবা সিজিপিএ ক্যালকুলেশনে পরিবর্তন করতে চাইলে শুধুমাত্র *CgpaCalculationService ক্লাসকেই আমার পরিবর্তন করতে হবে। প্রত্যেকটি ক্লাস একটি নির্দিষ্ট ডোমেইনে কাজ করবে বলে এটি সম্ভব হয়েছে। উপরোক্ত প্রতিটা ক্লাসেই আমি নতুন মেথড এড করতে পারি, যার জন্য অন্য কারো কাজে কোন ক্ষতিও হবে না। . একটি ক্লাস ভেঙ্গে নতুন ৩ টি ক্লাস তৈরি করার পরও এক জায়গায় সমস্যা রয়ে গেছে, সেটা CgpaCalculationService ক্লাসে। ক্যালকুলেটরের কাজ হবে শুধু ক্যালকুলেশন করে দেয়া, কম বা বেশি চেক করা তার কাজ হওয়া উচিত না। আবার সেটার প্রেক্ষিতে কোন একশন নেয়াও তার কাজের মধ্যে পড়ে না। এখন আমি মোবাইলে ম্যাসেজ পাঠাচ্ছি কিন্তু পরে মেইল যদি করার কথা চিন্তা করি কিংবা উভয়ই একসাথে করার কথা চিন্তা করি তবে কিন্তু আমার এই মেথডে পরিবর্তন আনতে হবে। . আসুন, এই সমস্যাটা কিভাবে দূর করা যায় তা একটু দেখে নিই। প্রথমে CgpaCalculationService ক্লাসকে পরিষ্কার করি। . class CgpaCalculationService: def calculate_semester_cgpa(self, course_gpas): # calculate semester_cgpa return semester_cgpa . আমরা কন্ডিশন চেকিং এর যে জায়গাটা গায়েব করে দিলাম সেটা তো কাউকে না কাউকে দেখতে হবে, এখন সেই ক্লাসটা তৈরি করা যাক - . class DecisionMakingService: def __init__(self, cgpa_calculation_service, minimum_cgpa, email_service, message_service): self.cgpa_calculation_service = cgpa_calculation_service self.minimum_cgpa = minimum_cgpa self.email_service = email_service self.messaging_service = messaging_service def make_decision(self, student_course_gpas): semester_cgpa = cgpa_calculation_service.calculate_semester_cgpa(student_course_gpas) if semester_cgpa &lt; self.minimum_cgpa: self.email_service.send_mail(&quot;আপনার ছেলে/মেয়ে পঁচা&quot;) self.messaging_service.send_message(&quot;আপনার ছেলে/মেয়ে পঁচা&quot;) return semester_cgpa . উপরোক্ত DecisionMakingService-এ আরো রিফ্যাক্টরিং করে উন্নতির সুযোগ আছে। তবে সেগুলো অন্য আরেকদিনের জন্য থাকলো। . Single Responsibility Principle বুঝতে পারা সব থেকে সহজ অন্য প্রিন্সিপলগুলো থেকে। কিন্তু এই প্রিন্সিপলটাই সবচেয়ে বেশি লঙ্ঘন করে থাকি আমরা। . দ্রষ্টব্যঃ এই লিখায় পাইথন কোডকে অনেকটা সুডোকোডের মতো করে ব্যবহার করা হয়েছে। আর লিখার মূল ফোকাস যেন একটি প্রিন্সিপলেই থাকে সেজন্য বেশকিছু জায়গায় ছাড় দিতে হয়েছে। লিখার কোন ভুল থাকলে জানাবেন এবং মাফ করবেন। . References . SOLID Principles: Explanation and examples | .",
            "url": "https://jabertuhin.github.io/jabers-blog/software%20design%20principle/software%20engineering/2020/06/19/single-responsibility-principle.html",
            "relUrl": "/software%20design%20principle/software%20engineering/2020/06/19/single-responsibility-principle.html",
            "date": " • Jun 19, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "ক্লাসিফিকেশন ইভ্যালুয়েশন মেট্রিসেস(Classification evaluation matrices) [পর্ব - ১]",
            "content": "আমরা মেশিন লার্নিং এর বিভিন্ন এল্গোরিদম ব্যবহার করে, বিভিন্ন ধরনের সমস্যা সমাধানের চেষ্টা করি। তার মধ্যে ক্লাসিফিকেশন নিয়ে সম্ভবত আমরা সবচেয়ে বেশি কাজ করে থাকি। কিভাবে এই এল্গোরিদমগুলোকে মূল্যায়ন করা যায় তার কিছু পদ্ধতি দেখে নিবো। নতুবা বুঝবো কিভাবে কোন নির্দিষ্ট কাজের জন্য আমার কোন এল্গোরিদম ব্যবহার করা উচিত? . ক্লাসিফিকেশন একুরেসি(Classification Accuracy) . একুরেসি শব্দটা যখন আমরা ব্যবহার করি তখন আমরা আসলে এই ক্লাসিফিকেশন একুরেসিকেই বুঝিয়ে থাকি। ছোটবেলা থেকে যেধরনের হিসেব করে আমরা অভ্যস্ত এটা ঠিক সেরকম কিছুই। কোন জটিল, মারপ্যাঁচ নেই। . Accuracy=Number of correct predictionsTotal number of predictions made text{Accuracy} = frac{ text{Number of correct predictions}}{ text{Total number of predictions made}}Accuracy=Total number of predictions madeNumber of correct predictions​ . অর্থাৎ, আমাকে যদি ১০০ টা প্রেডিকশন করতে হয় যার - মধ্যে ৯০ টা সঠিকভাবে করতে পারি আর বাকি ১০ টা ভুল করি। তবে, উপরের সূত্রমতে আমার ক্লাসিফিকেশন একুরেসি আসবে ৯০%( ৯০১০০ frac{৯০}{১০০}১০০৯০​) । . এই পদ্ধতি, একটা মডেল কতটা ভালোভাবে প্রেডিক্ট করতে পারছে কিংবা তার কার্যকারিতা সম্পর্কে জানার জন্য যথেষ্ট নয়। ধরি, Kaggle এর বিখ্যাত টাইটানিক কম্পিটেশনের জন্য তৈরি একটি মডেলের ক্লাসিফিকেশন একুরেসি ভ্যালিডেশন(validation) স্টেজে পেলাম ৯৮% - তাহলে কি সেটা দারুন কোন মডেল? যদি খেয়াল করে দেখি সে সবসময়ই “1” প্রেডিক্ট করছে (অর্থাৎ যাত্রী বেঁচে গিয়ে ছিল। ‘0’ দ্বারা দূর্ঘটনায় মৃতদের বোঝায়।),যে ডাটা দিয়ে মডেলকে প্রেডিক্ট করতে বলা হচ্ছে সেখানে ১০০ টার মধ্যে ৯৮ টাই বেঁচে যাওয়া মানুষের ডাটা ছিল। যেটার জন্য আসলে “মেশিন লার্নিং”-ই প্রয়োজন নেই, শুধু “print” সেটেটমেন্ট দিয়ে “1” প্রিন্ট করে দিলেই হয় যাবে। কিন্তু সেটা কি টেস্ট ফাইলে কাজ করবে? সেখানে এই মডেল মুখ থুবড়ে পড়ে থাকবে। . কনফিউশন মেট্রিক্স(Confusion Matrix) . কোন মডেল কতটুকু ভালোভাবে প্রেডিক্ট করতে পারছে তা জানা ও বুঝার জন্য এই মেট্রিক্স খুবই গুরুত্বপূর্ণ। আমরা কোন একটা বাইনারি ক্লাসিফিকেশন প্রবলেমের কথা চিন্তা করি। ব্রেস্ট ক্যান্সার ডাটাসেটের সাথে সবারই কমবেশি পরিচয় থাকার কথা। যে ডাটাসেট ইউজ করে কারো ব্রেস্ট ক্যান্সার শনাক্ত করতে পারি। যেহেতু এখানে সম্ভাব্য আউটপুট তথা ক্লাস(ব্রেস্ট ক্যান্সার আছে, ব্রেস্ট ক্যান্সার নেই) দু’টি তাই এটিকে বাইনারি ক্লাসিফিকেশন প্রবলেম বলা হচ্ছে। . এখানে মডেলের ভুলটা আমরা কিভাবে চিন্তা করতে পারি? আমার মডেল বলছে যার ক্যান্সার আছে, সেক্ষেত্রে দু’টো সম্ভাবনা থাকে - তার আসলেই ক্যান্সার আছে, নয়তো ক্যান্সার না থাকার পরও আমার মডেল বলছে তার ক্যান্সার আছে। . আর যার ক্যান্সার নেই সেক্ষেত্রেও এমন ভুল হতে পারে যে, তাকে বলছে তার ক্যান্সার আছে। এভাবে আমরা মোট ৪ টা সিনারিও পাই - . . ছবির Predicted - YES/NO আমার মডেলের উত্তর, আর Actual YES/NO আমার কাছে যে ডাটা আছে সেটার উত্তর(বাস্তব)। . True Positive - বলতে বুঝায় আমার মডেল বলছে রোগীর ব্রেস্ট ক্যান্সার আছে এবং বাস্তবেও(ডাটাসেটেও) দেখা যাচ্ছে তার ক্যান্সার আছে। সুতরাং, যখন প্রেডিক্টেড পজেটিভ রেজাল্ট আর বাস্তবের পজেটিভ রেজাল্ট মিলে যায় সেটা। . False Negative - যখন আমার মডেল বলছে রোগীর ব্রেস্ট ক্যান্সার হয় নি কিন্তু বাস্তবে তার ক্যান্সার আছে। সুতরাং, যখন প্রেডিক্টেড রেজাল্ট নেগেটিভ কিন্তু বাস্তবের রেজাল্ট পজেটিভ থাকে। . False Positive - যখন আমার মডেল বলছে রোগীর ক্যান্সার আছে কিন্তু বাস্তবে রোগীর ক্যান্সার নেই। সুতরাং, প্রেডিক্টেড রেজাল্ট পজেটিভ কিন্তু বাস্তবের রেজাল্ট নেগেটিভ। . True Negative - যখন আমার মডেল বলছে রোগীর ক্যান্সার নেই এবং বাস্তবেও রোগীর ক্যান্সার নেই। সুতরাং, প্রেডিক্টেড রেজাল্ট নেগেটিভ এবং বাস্তবের রেজাল্টও নেগেটিভ। . আমরা যে উপরে ক্লাসিফিকেশন একুরেসি বের করেছি সেখানে - . Number of correct predictions=True Positive + True Negative text{Number of correct predictions} = text{True Positive + True Negative}Number of correct predictions=True Positive + True Negative . আমরা এখন মডেলের পার্ফর্মেন্স আরেকটু ভালোভাবে বুঝতে কিছু প্রশ্ন করতে পারি। আমাদের মডেল যাদের ক্যান্সার রোগীকে শনাক্ত করছে সেটা কতটুকু বিশ্বাসযোগ্য? . প্রেসিশন(Precision) . প্রেসিশন(Precision) আমাদের উপরের প্রশ্নের উত্তর দিবে - . Precision=True PositiveTrue Positive + False Positive text{Precision} = frac{ text{True Positive}}{ text{True Positive + False Positive}}Precision=True Positive + False PositiveTrue Positive​ . এর মান কম আসলে বুঝতে পারবো আমাদের মডেল ক্যান্সার রোগীকে সঠিকভাবে শনাক্ত করতে পারছে না বরং যাদের ক্যান্সার নেই তাদের ক্যান্সার রোগী হিসেবে শনাক্ত করছে। উদাহরণ দিয়ে যদি বুঝতে চেষ্টা করি - . True Positive(TP) = 1 . False Positive(FP) = 2 . Precision=TPTP+FP=11+2=0.33Precision = frac{TP}{TP + FP} = frac{1}{1 + 2} = 0.33Precision=TP+FPTP​=1+21​=0.33 . সুতরাং, আমার মডেল যদি ১০০ জন ক্যান্সার রোগী শনাক্ত করে তবে তার মধ্যে কেবল ৩৩ জন প্রকৃতপক্ষে ক্যান্সার রোগী। . রিকল(Recall) . এখন প্রশ্ন যদি হয় - আমাদের মডেল প্রকৃতপক্ষে কত ক্যান্সার রোগীকে শনাক্ত করতে পেরেছে? . এই প্রশ্নের উত্তর রিকল(Recall) থেকে পাবো আমরা। . Recall=True PositiveTrue Positive + False Negative text{Recall} = frac{ text{True Positive}}{ text{True Positive + False Negative}}Recall=True Positive + False NegativeTrue Positive​ . এখন আমরা ছোট একটা উদাহরণ দিয়ে বুঝে নিই - . True Positive(TP) = 1 . False Negative(FN) = 9 . Recall=TPTP+FN=11+9=0.1Recall = frac{TP}{TP + FN} = frac{1}{1 + 9} = 0.1Recall=TP+FNTP​=1+91​=0.1 . এর মানে দাঁড়াচ্ছে, মোট ১০ জন ক্যান্সার রোগীর মধ্যে সে ১ জনকে সঠিকভাবে শনাক্ত করতে পেরেছে। . Update-1 on September 14th . এফ ওয়ান স্কোর(F1 Score) . প্রেসিশন এবং রিকল দুইটা আলাদা প্রশ্নের উত্তর দেয়। কিন্তু আমার মডেলকে ঠিকভাবে মূল্যায়নের জন্য আসলে এদের যেকোন একজনকে নয় বরং উভয়কেই প্রয়োজন। দুইটার মধ্যে একটা সামঞ্জস্য করে কিছু করতে পারলে আমাদের জন্য মঙ্গল। সেই কাজের দায়িত্ব নেয় - এফ ওয়ান স্কোর(F1 score)। একে “এফ স্কোর”(F score) অথবা “এফ মেজার”(F measure)-ও বলা হয়ে থাকে। সমীকরণের মাধ্যমে যদি আমরা দেখতে চাই - . F1=2∗11precision+1recall=2∗precision∗recallprecision+recallF1 = 2 * frac{1}{ frac{1}{precision} + frac{1}{recall}} = 2 * frac{precision * recall}{precision + recall}F1=2∗precision1​+recall1​1​=2∗precision+recallprecision∗recall​ . প্রেসিশন এবং রিকল-কে ধরে এরিথমেটিক মিন(arithmetic mean) বের করা হয় নি। কারণ দুইটার হর(denominator) আলাদা। চাইলেই দু’টি সংখ্যার গড় বের করা সম্ভব - যোগ করে, ২ দিয়ে ভাগ দিয়ে। কিন্তু তাতে কি আদৌ কোন অর্থবহ মানে বের করা সম্ভব হবে? . যার জন্য প্রেসিশন আর রিকলের হার্মোনিক মিন(Harmonic mean) বের করা হয়। আর এই গড়কে “এফ ওয়ান স্কোর”(F1 Score) বলে। এর মানের রেঞ্জ [০,১] . Resources . 1 - Metrics To Evaluate Machine Learning Algorithms in Python . 2 - Metrics to Evaluate your Machine Learning Algorithm . 3 - Classification: True vs. False and Positive vs. Negative .",
            "url": "https://jabertuhin.github.io/jabers-blog/machine%20learning/2019/09/10/classification-evaluation-matrices-part-1.html",
            "relUrl": "/machine%20learning/2019/09/10/classification-evaluation-matrices-part-1.html",
            "date": " • Sep 10, 2019"
        }
        
    
  
    
        ,"post6": {
            "title": "ওভারফিটিং, আন্ডারফিটিং [মেশিন লার্নিং টুকিটাকি]",
            "content": "অগা-মগা-বগা তিন ঘনিষ্ট বন্ধু। ওয়াহিদ স্যার ওদের ক্লাসের গণিতের শিক্ষক। এর আগের বছরও ওয়াহিদ স্যারকে ওরা গণিত ক্লাসে পেয়েছিল। স্যারের ক্লাসের ধরনের সাথে ওরা বেশ পরিচিতই। স্যার ক্লাসে যেগুলো করায় ঐগুলোই আবার বাড়ির কাজ হিসেবে দেয়। আর প্রতি চ্যাপ্টারে যেই অনুশীলনি থাকে সেগুলো থেকে ক্লাস টেস্টের প্রশ্ন করে। গাইড বই এর সাহায্য নিয়ে অনুশীলনিগুলো খুব সহজেই করা সম্ভব। . ওরা তিন বন্ধুই এইসব জানে, কিন্তু বগার পড়াশোনায় কোন মন নেই। আর গণিত সে একেবারেই পছন্দ করে না। তাই সে ক্লাসে স্যার যখন পড়ায় তখন খাতায় তা তুলে নেয় না, বাড়ির কাজও করে নিয়ে আসে না। তাই ক্লাস-টেস্টেও খারাপ করে। আর মগা খুব মনোযোগী ছাত্র, সে স্যারের বলা প্রতিটা কথা পর্যন্ত খাতায় তুলে, সব কাজ ঠিক ঠাক করে। তাই মগা ক্লাস-টেস্টেও ফুল মার্ক পায়। . বাকি থাকে অগা, যে কি-না সব বুঝে বুঝে করতে বধ্য-পরিকর। না বুঝে একটা অংকও সে করতে রাজী না। স্যারের কথা মনোযোগ দিয়ে শুনে, কোন লাইনের পরে কোন লাইন কেন লিখা হচ্ছে তা চিন্তা করে। বাড়ির কাজ পুরো শেষ করতে না পারলেও যতোটুকু করে নিজে বুঝে বুঝে করে। ক্লাস-টেস্টে মগার মতো ফুল-মার্ক না পেলেও খারাপ করে না। . এভাবেই তারা ছয় মাস পাড় করে দিলো, এবার সামনে প্রথম সাময়িক পরীক্ষা। স্কুলের নতুন নিয়ম অনুযায়ী পরীক্ষার প্রশ্ন সব গণিত শিক্ষকের কাছ থেকে নিয়ে সম্মিলিতভাবে করা হবে। পরীক্ষা ভালো মতো হলো, পরীক্ষা শেষের কয়েকদিন পরই পরীক্ষার খাতা দেয়া হলো। কি মনে হয় কে কেমন করলো এই তিন বন্ধুর মধ্যে? . বগা যে খারাপ করবে তা সবাই বুঝতেই পারছি। মূল প্রশ্নটা হলো – অগা আর মগা কি করলো? মগা বেশ খারাপ করেছে, তার মতো ক্লাসের সব কিছুতে ফুল মার্ক পাওয়া একজন ছাত্র কি-না গণিতে ৬০ পেলো। আর অগা কি-না পেলো ৮৫। এর কারণ পরীক্ষার প্রশ্নে বেশকিছু অংক অন্য বই থেকে নেয়া হয়েছিল। যদিও টপিক এক থাকলেও প্রশ্ন কমন পড়ে নি তাই মগা আর সেই প্রশ্নের উত্তরই দিতে পারে নি। আর অগা বুঝে বুঝে পড়েছে বিধায় নতুন প্রশ্ন তার জন্য কোন সমস্যা ছিল না, সে তো বুঝে বুঝেই উত্তর করেছে যতোটুকু পেরেছে। . এবার ফিরে আসি যা বুঝাতে এই গল্পের আবির্ভাব। বগার অবস্থাটাকে মেশিন লার্নিং-এ underfitting বলে, মগার অবস্থাকে overfitting এবং অগার অবস্থাটাকে মেশিন লার্নিং এর আদর্শ অবস্থা বলা চলে। . এখন আরেকটু টেকনিকালভাবে বিষয়গুলো বুঝতে চেষ্টা করি – মেশিন লার্নিং এর বিভিন্ন স্টেপের মধ্যে একটি স্টেপ হলো – মডেল সিলেকশন। কোন মডেল নিয়ে আমি এগুতে চাই সেটা নির্ধারণ করা। কি দেখে এই সিলেকশনটা করা হয় তা একটু জেনে নিই। . আমাদের কাছে নির্দিষ্ট পরিমাণ ডাটা থাকে যা দিয়ে আমাদের কাজ করতে হয়। যেটা ডাটাসেট নামেই বেশি পরিচিত। এই নির্দিষ্ট সংখ্যক ডাটাসেটের ডাটা পয়েন্ট নিয়েই আমাকে যা করার তা করতে হবে। খুব আদর্শ ধরা হয় – ৬০% ডাটা দিয়ে মডেল ট্রেইন করা, ২০% দিয়ে ক্রস-ভ্যালিডেশন করা আর বাকি ২০% দিয়ে মডেল টেস্ট করা। আমরা মূলত এখন ট্রেইন এর ৬০% আর cross-validation এর ২০% নিয়ে কথা বলবো। . বোঝার সুবিধার্থে ধরি, আমাদের ডাটাসেটে মোট ১০০টা ডাটা পয়েন্ট আছে। যার ৬০ টা দিয়ে আমি ট্রেইন করাবো, আর ২০ টা দিয়ে ক্রস-ভ্যালিডেশন করবো। m = training set size = 60 আর দুইটা মডেল ধরি, model1 এবং model2. . আমরা প্রথমে মডেলকে ১ টি ডাটা পয়েন্ট দিয়ে ট্রেইন করবো, এরপর ক্রস ভ্যালিডেশনে তার পার্ফরমেন্স দেখবো। এরপর ২-টি ডাটা পয়েন্ট দিয়ে, ৩-টি দিয়ে, এভাবে ৬০-টি ডাটা পয়েন্ট দিয়ে আমরা মডেলকে ট্রেইন করবো। আমরা এখানে মূলত আমাদের ডাটাসেটে মডেল কি ধরনের আচরন করে তা দেখতে চাচ্ছি, যার জন্য এভাবে ভেঙ্গে ভেঙ্গে কাজ করছি। ট্রেইনিং এর পরে উক্ত মডেল কতটা ভালোভাবে কাজ করছে তা দেখার জন্য ক্রস ভ্যালিডেশন ব্যবহার করা হয়। সেই আলাদা করে রাখা ২০ টা ডাটা পয়েন্ট। এর মধ্যে কতটা সঠিক উত্তর দিতে পারছে আর কতটা ভুল সেটার শতকরা প্রকাশ হলো cv_error। . এখানে খেয়াল করার বিষয় আমরা ট্রেইন করার জন্য ধীর ধীরে ডাটা পয়েন্ট বাড়াচ্ছি কিন্তু ক্রস ভ্যালিডেশনের সাইজ সবসময় ফিক্সড থাকবে যা কি-না ২০। . এখন মেশিন লার্নিং এর ক্ষেত্রে আমরা কি করি কিংবা কি চাই? আমরা মেশিনকে কিছু একটা শিখিয়ে পরবর্তীতে দেখতে চাই সে কতটুকু শিখলো? কতটুকু ঠিকভাবে সে প্রেডিক্ট করতে পারছে। আমরা শতকরা হিসেবে তা প্রকাশ করে থাকি। ৮৫% একুরেসি মানে ১০০ বারের মধ্যে সে ৮৫ বার সঠিক উত্তর দিচ্ছে আর বাকি ১৫ বার ভুল উত্তর দিচ্ছে। আমরা এখন তার এই ভুল করার ব্যাপারটা গ্রাফের মাধ্যমে দেখি সাথে দুইটা নতুন টার্মস এর সাথেও পরিচিত হবো(bias and variance)। Model1 এর ক্ষেত্রে নিম্নোক্ত গ্রাফটি পাই – . . এই ধরনের গ্রাফকে লার্নিং কার্ভ বলা হয়। ট্রেইনিং ডাটা এর ক্ষেত্রে মডেল যে ইরোর দেয় সেটা training_error এবং cross validation এর সময় যে ইরোর দেয় সেটা cv_error. X – axis রিপ্রেজেন্ট করছে যে পরিমাণ ডাটা দিয়ে আমি আমার মডেলকে ট্রেইন করছি তা(১ – ৬০ পর্যন্ত যে ধীরে ধীরে যাচ্ছি) এবং Y-axis রিপ্রেজেন্ট করছে ইরোরের পরিমাণকে(কতটুকু ভুল করছে)। . Model1 এর ক্ষেত্রে যতো বেশি ডাটা দিয়ে ট্রেইন করছি ততো বেশি ইরোর পাচ্ছি এবং cv_error আগের থেকে কমলেও ট্রেইনিং ইরোরের খুব কাছে। তার মানে দুই-ক্ষেত্রেই অনেক বেশি ইরোর দিচ্ছে। গল্পের বগার মতো ক্লাসেও খারাপ করছে আবার পরীক্ষাতেও খারাপ করছে। training_error এর উঠতি মানকে High Bias বলা হয়। Model2 এর ক্ষেত্রে নিম্নোক্ত গ্রাফটি পাই – . . এখানে দেখতে পাচ্ছি training_error এর তুলনায় cv_error যথেষ্ট বেশি। যা বুঝাচ্ছে মগার মতো ক্লাসে খুবই ভালো রেজাল্ট করছে কিন্তু নতুন কোন প্রশ্ন একটু ঘুরিয়ে দিলেই আর পারছে না। এইখানে আরেকটা বিষয় লক্ষ্য করার তা হলো দুইটা ইরোরের মধ্যবর্তী ফাঁকা জায়গাটা, যা বেশ অসামঞ্জস্যপূর্ণ। cv_error এর মান training_error এর তুলনায় এতো বেশি হওয়াকে High Variance বলা বলা হয়। . Bias-Variance Trade-off বলে একটা কথা আছে, যার মাধ্যমে আমরা মডেল সিলেক্ট করে থাকি। Low bias যেখানে থাকবে সেখানে high variance থাকবে এবং যেখানে High bias থাকবে সেখানে Low Variance থাকবে। সবসময় চেষ্টা করা হয় যথাসম্ভব low bias রেখে variance ও low রাখার। কিন্তু দুইটাকেই একত্রে কমিয়ে রাখা সম্ভব না। এসবক্ষেত্রে একটু ছাড় দিয়ে এগুতে হয়। অনেকটা অগা-এর মতো, সব পড়ে সে শেষ করতে পারতো না। কিন্তু যা পড়তো বুঝে বুঝে পড়তো, পরীক্ষায় কিন্তু সে ১০০ পায় নি কিন্তু যথেষ্ট ভালো পেয়েছিল(৮৫)। . ৬ থেকে ৭ টা মডেলের মধ্য থেকে যদি আমাকে একটা বাছাই করতে হয়, তখন আমি সেটাকেই বাছাই করবো যার লার্নিং কার্ভ দেখে বুঝতে পারবো সেখানে overfitting কিংবা underfitting এর সম্ভাবনা যথাসম্ভব কম। ভালো মডেলটাই তো টেস্ট সেটে ভালো উত্তর দিতে পারবে, তখনই কেবল তাকে দিয়ে কাজ করানো সম্ভব বাস্তব জগতে। . [ লিখায় কোন ভুল-ত্রুটি থাকলে মন্তব্যে তা ধরিয়ে দিবেন আশা করি। ধন্যবাদ ] .",
            "url": "https://jabertuhin.github.io/jabers-blog/machine%20learning/2019/09/06/overfitting-underfitting.html",
            "relUrl": "/machine%20learning/2019/09/06/overfitting-underfitting.html",
            "date": " • Sep 6, 2019"
        }
        
    
  
    
        ,"post7": {
            "title": "টু পয়েন্টার, Two Pointer (Lec - 2.1)",
            "content": "আমরা প্রত্যেকেই ছোটবেলায় একটা গল্প শুনেছি অথবা পড়েছি। দুই ইঁদুর আর এক বানরের। গল্পটা অনেকটা এইরকম যতদূর মনে পড়ে- . দুই বানর একটা রুটি চুরি করে। এখন দুইজনে সমান দুই ভাগ করে যে রুটিটা খাবে সেটা আর পারছে না। তাদের পাশ দিয়ে হঠাৎ করে একটা বানর যাচ্ছিল। তারা ঠিক করলো বানরকে দিয়ে রুটিটা দুই ভাগ করাবে।  বানর খুশি খুশিই রাজী হয়ে গেলো। প্রথমে রুটিটাকে দুই ভাগ করলো এরপর দেখলো একপাশে একটু বেশি আছে। সেইপাশ থেকে অল্প একটু ছিড়ে খেয়ে ফেললো। এরপর দেখলো আরেক পাশের রুটি এখন একটু বেশি মনে হচ্ছে। এরপর সেই অংশ থেকে রুটি একটু ছিড়ে খেয়ে ফেললো। . যাদের গল্পের বাকি অংশ জানার ইচ্ছা গুগল করে জেনে নিয়ো :P আমার যতটুকু প্রয়োজন ততোটুকু বলে ফেলেছি। . জিনিসটা হচ্ছে ব্যালেন্সিং করা। কোন পাশে কমে গেলে আরেক পাশ থেকে একটু কমিয়ে আনা। বা কোন অংশে বেড়ে গেলে আরেক পাশকে বাড়ানোর চেষ্টা করা। যেমন বাজারে ১ কেজি চাল কিনতে গেলে প্রথমে পাল্লার এক পাশে এক কেজির বাটখাড়া রাখা হয় এরপর অন্য পাশে চাল ওজন করা হয়। প্রয়োজনের চেয়ে বেশি চাল উঠলে কমানো হয় আবার কম উঠলে আরো কিছু চাল এনে দেয়া হয়। . “টু পয়েন্টার” হলো একটা টেকনিক। সাধারণত একটি বিশেষ জোড়া বের করার জন্য ব্যবহৃত হয়। . উদাহরণ দিয়ে একটু বুঝার চেষ্টা করি। . 4 এর সমান অথবা 4  হতে বড় যেকোন সংখ্যাকে দু’টি প্রাইম নাম্বারের যোগফল রূপে প্রকাশ করা সম্ভব। . 4 = 2 + 2 . 5 = 2 + 3 . 6 = 3 +3 . 7 = 2 + 5 . 8 = 3 + 5 . 9 = 2 + 7 . 10 = (3+7) or (5 + 5) . আমাকে যদি কোন নাম্বার দিয়ে বলা হয় যে সেই নাম্বারকে দু’টি প্রাইম নাম্বারের যোগফল রূপে দেখাতে (উপরের উদাহরণের মতো) সেক্ষেত্রে আমরা Two Pointer টেকনিক ব্যবহার করতে পারি। . [এখানে প্রাইম নাম্বার নিয়ে চিন্তা করাটা মূল ব্যাপার না। মূল ব্যাপার হচ্ছে এই যোগফলটা কিভাবে বের করা সম্ভব] . Two pointer টেকনিক ব্যবহার করার আগে এরেকে(যেখান থেকে আমি কোন তথ্য চাচ্ছি । উপরের উদাহরনে যেমন প্রাইম নাম্বারের একটা এরে থেকে) সেটা সোর্টেড হতে হবে। নাহলে কমানো বা বাড়ানোর কাজটা ঠিক করা যাবে না। . উপরের প্রবলেমের কোডটা নিচে দেয়া হলো- . . এখানে primeNum এর একটা এরে নিলাম আমরা প্রথমে (যেখানে সবকয়টা প্রাইম নাম্বার রাখা)। এরপর ইউজারের কাছ থেকে একটা ইনপুট নিবো যেটাকে আমার দু’টো প্রাইম নাম্বারের সমষ্টি রূপে দেখাতে হবে। . এরেতে খেয়াল করলে দেখবো নাম্বারগুলো ছোট থেকে বড় আকারে সাজানোই আছে। . এবার আমার দুইটা পয়েন্টার লাগবে। যে জিনিস দিয়ে আমি ওজন (এক্ষেত্রে যোগফল) বাড়ানো কমানোর কাজটা করবো। . left এবং right দুইটা ভেরিয়েবল নিলাম। left এর ভ্যালু 0 অর্থাৎ সবচেয়ে ছোট প্রাইম নাম্বারকে যে পয়েন্ট করে থাকবে। আর right এর ভ্যালু 9 (length or size of the array) সবচেয়ে বড় প্রাইম নাম্বারটাকে পয়েন্ট করে থাকবে। . এই ভেরিয়েবল দুটি আদতে এরের index এর ভ্যালু হোল্ড করে। যেটাকে আমরা বলছি এরেতে ছোট কিংবা বড় ভ্যালুকে পয়েন্ট করে থাকে। . এরপরেই একটা লুপ চালাচ্ছি যতক্ষণ পর্যন্ত left  এর মান right এর ছোট থাকবে অথবা সমান হবে ততক্ষণ পর্যন্ত লুপটা চালিয়ে আমি আমার কাঙ্ক্ষিত প্রাইম যুগল বের করার চেষ্টা করবো। . একটা ইনপুটের জন্য লুপটা চালিয়ে দেখি। ধরলাম ইনপুট 10 . ১ম বার =&gt; . left = 0, right = 9 . sum = primeNum[0] + primeNum[9]  = 2 + 29 = 31 . এই ৩১ ভ্যালুটা কি আমার কাঙ্ক্ষিত ভ্যালু ১০ এর সমান? না , তাহলে  বড় না ছোট? . ১০ থেকে ৩১ বড়। . তাহলে আমাকে এমনকিছু করতে হবে যেন পরেরবার ভ্যালুটা ১০ এর কাছাকাছি যায়। মানে ৩১ এর থেকে কম আসে। আমার right পয়েন্ট করে আছে সবচেয়ে বড় ভ্যালুকে আর let ছোট ভ্যালুকে। দুইটার যোগফল ছোট করার জন্য আমাড় কি করা দরকার? right এখন যাকে পয়েন্ট করে আছে তার চেয়ে ছোট ভ্যালুকে যেন এরপরেরবার পয়েন্ট করে। সুতরাং right- -, right এর ভ্যালু এক কমে 8 এখন। . ২য় বার =&gt; . left = 0, right = 8 . sum = primeNum[0] + primeNum[8]  = 2 + 23 = 25 . এইবারও যোগফল ১০ এর থেকে বেশি right এর মান আবার কমাবো right- -, right = 7। . ৩য় বার =&gt; . left = 0, right = 7 . sum = primeNum[0] + primeNum[7]  = 2 + 19 = 21 . এইবারও যোগফল ১০ এর থেকে বেশি right এর মান আবার কমাবো right- -, right = 6। . ৪র্থ বার =&gt; . left = 0, right = 6 . sum = primeNum[0] + primeNum[6]  = 2 + 17 = 19 . এইবারও যোগফল ১০ এর থেকে বেশি right এর মান আবার কমাবো right- -, right = 5। . ৫ম বার =&gt; . left = 0, right = 5 . sum = primeNum[0] + primeNum[5]  = 2 + 13 = 15 . এইবারও যোগফল ১০ এর থেকে বেশি right এর মান আবার কমাবো right- -, right = 4। . ৬ষ্ঠ বার =&gt; . left = 0, right = 4 . sum = primeNum[0] + primeNum[4]  = 2 + 11 = 13 . এইবারও যোগফল ১০ এর থেকে বেশি right এর মান আবার কমাবো right- -, right = 3। . ৭ম বার =&gt; . left = 0, right = 3 . sum = primeNum[0] + primeNum[4]  = 2 + 7 = 9 . এইবার কিন্তু যোগফল ১০ এর থেকে ছোট হয়ে গেলো । এখন এমন কিছু করতে হবে যেন যোগফলটা বাড়ে । যেহেতু যোগফলটা ১০ এর চেয়ে ছোট । এই বাড়ানোর জন্য আমার এখন সবচেয়ে ছোট ভ্যালুটা চেঞ্জ করতে হবে । সুতরাং left এখন যাকে পয়েন্ট করে আছে পরে যেন তার থেকে বড় কাউকে পয়েন্ট করে । left++, left = 1 হয়ে গেলো এখন . ৮ম বার =&gt; . left = 1, right = 3 . sum = primeNum[1] + primeNum[4]  = 3 + 7 =  10 . টাডা, 10 পেয়ে গেলাম । এবার যেহেতু আমার কাঙ্ক্ষিত নাম্বার পেয়ে গেছি। লুপ ব্রেক করে বাহিরে চলে আসছি আমি। . আর left আর right এর কাছে যেহেতু এরের ইন্ডেক্সের মান আছে সেহেতু পরে তা সরাসরি প্রিন্ট করে দিচ্ছি। আউটপুট দেখতে অনেকটা এই রকম হবে- . stdin . 10 . stdout . 10 = 3+7 . [ উদাহরণে লুপের কন্ডিশনটা আলাদা করে চেক করে অহেতুক লিখা বড় করা হয় নি । যেহেতু লুপ চলছে প্রতিবারই কিন্তু কন্ডিশন চেক হচ্ছে । আর left কিন্তু সবসময়ই right এর থেকে ছোট ছিল ] . Practice Problem: . 11057 - Exact Sum . 543 - Goldbach’s Conjecture (এইটা সলভ করার জন্য আগে প্রাইম নাম্বার জেনারেট করা শিখতে হবে) .",
            "url": "https://jabertuhin.github.io/jabers-blog/c++/competitive%20programming/2017/08/12/cp-two-pointer.html",
            "relUrl": "/c++/competitive%20programming/2017/08/12/cp-two-pointer.html",
            "date": " • Aug 12, 2017"
        }
        
    
  
    
        ,"post8": {
            "title": "C++ বেসিক ধারণা, কিউ(Queue) (Lec - 1.7)",
            "content": "আমরা জেনে অথবা না জেনে প্রতিনিয়ত এই ধারণা ব্যবহার করে থাকি। ব্যাংকের লম্বা লাইনে, বাসের লাইনে , ভার্সিটিতে প্রবেশের সময় গেটের চেকিং এর লম্বা লাইনে আমরা প্রতিনিয়ত দাঁড়িয়ে থাকি। লাইনের শুরুতে যে দাঁড়িয়ে থাকে সেই সর্বপ্রথম তার কাজ করার সুযোগ পায়। . যে ব্যাংকে টাকা জমা দিতে লাইনের শুরুতে দাঁড়িয়ে থাকে সে টাকা জমা দিয়ে লাইন থেকে বেরিয়ে যায়। এরপর তার পিছনের মানুষটি টাকা জমা দেয়ার সুযোগ পায়। এভাবে একটা নিয়ম মেনে টাকা জমার কাজ হতে থাকে। . এইটাই মূলত queue এর কাজ। এটি একটি ডাটা স্ট্রাকচার। FIFO(First In First Out) রুলস মেনে চলে। . . (Paint ব্যবহার করে চিত্রটা এঁকেছি যতটুকু সম্ভব হয়েছে আমার দ্বারা।) . কিউ জিনিসটা অনেকটা এই চিত্রের মতোই। এইখানের জিনিসটা গুরুত্বপূর্ণ - চিত্রের টিউবের ভিতরে প্রবেশ করা সম্ভব একমাত্র ডানদিক থেকে। আর বের হওয়া সম্ভব একমাত্র বামদিক থেকে। অন্য কোন ভাবে টিউবে প্রবেশ করা কিংবা বের হওয়া সম্ভব না। . ধরি, ব্যাংক যখন খুলে তখন টাকা তোলার লাইন খালি থাকে । তখন আমি যদি লাইনে দাঁড়াই এটাকে বলবো ভ্যালু পুশ(push) করা। . queue ডিক্লেয়ারেশন করতে হয় -&gt; . queue variable_name; . Example –&gt;  queue qU; . প্রাথমিকভাবে এই কিউ খালি থাকবে । . এখন এর মধ্যে ভ্যালু রাখতে হলে আমাকে সেই ভ্যালু পুশ করতে হবে। . qU.push(3); . qU.push(4); . qU.push(5); . তাহলে আমার কিউতে এখন আছে তিনটা এলিমেন্ট যথাক্রমে -&gt; 3,4,5 . জিনিসটা এইভাবে চিন্তা করি, ব্যাংকের লাইনে ৩ নাম্বার জ্যাকেট পড়া এক ব্যক্তি দাঁড়ানো এরপর ৪ নাম্বার এবং এরপরে ৫ নাম্বার জ্যাকেট পড়া ব্যক্তি দাঁড়ানো আছে। . সবার প্রথমে ৩ নাম্বার জ্যাকেট পড়া ব্যক্তি লাইন থেকে বের হয়ে যাবে। . এই অপারেশনটা করার কমান্ড লাইন হলো- . qU.pop(); . তাহলে প্রথম এলিমেন্টটা বের হয়ে যাবে । . আবার আমি যদি প্রথম এলিমেন্টটা দেখতে চাই তাহলে কমান্ড হবে এইরকম- . q.front(); . এইটা কিউয়ের সামনের এলিমেন্টটা রিটার্ন করবে। কিন্তু ভ্যালুটা বের করে দিবে না।  আরেকভাবে বলতে গেলে শুধু প্রথম ভ্যালুটার মান আমাকে জানাবে। . মনে রাখতে হবে pop() অপারেশনটা শুধু প্রথম এলিমেন্টটা বের করে দিবে। . আর queue এ বর্তমানে কয়টা এলিমেন্ট আছে সেটা জানার জন্য কমান্ড হলো -&gt; . qU.size(); . এই size() ফাংশনটা ভ্যালু রিটার্ন করে । . কিউ(queue)কি খালি নাকি না সেটা চেক করার একটা বুলিয়ান রিটার্ন টাইপের ফাংশন আছে । . qU.empty() -&gt; True রিটার্ন করবে যদি তা খালি থাকে অন্যথা False রিটার্ন করবে । . গ্রাফ ট্রাভার্সাল এল্গোরিদম BFS এ এই ডাটা স্ট্রাকচার ব্যবহার করা হয় । . Practice Problems- . Basics of Queues . UVA - 10935 .",
            "url": "https://jabertuhin.github.io/jabers-blog/c++/competitive%20programming/2017/05/23/cpp-basic-queue.html",
            "relUrl": "/c++/competitive%20programming/2017/05/23/cpp-basic-queue.html",
            "date": " • May 23, 2017"
        }
        
    
  
    
        ,"post9": {
            "title": "কম্পিটিটিভ প্রোগ্রামিং -এ আমার পদার্পণ",
            "content": "ব্র্যাকে ভর্তি হয়ে বেশ কিছুদিন(কয়েক মাস,এখনও কিছু সময়ের জন্য সত্য) ধরে প্রচন্ড রকমের মন খারাপ। কোন একদিন ফেসবুকে ব্র্যাকে ভার্সিটি রিলেটেড সব গ্রুপে জয়েনে রিকুয়েস্ট করি। সেভাবেই এই গ্রুপের সন্ধান পাওয়া। . বিভিন্ন মানুষের লিখা পড়ার কারণে কন্টেস্ট সম্পর্কে ভাসা ভাসা আইডিয়া ছিল। কিন্তু ভার্সিটিতে ভর্তি হয়েই programming language সহ বিভিন্ন টার্মের সাথে প্রথম পরিচয়। spring15 এর সেমিস্টার ব্রেকের কিছু আগে ঢাবির এক বন্ধুর(নাবিল) মাধ্যমে uri online judge এর খবর পাই। সলভ করতে গিয়ে প্রথম প্রবলেম সাবমিট করেই WA (uri 1001 may be)। এই গ্রুপে (BRACU Programming Contest Enthusiasts)পোস্ট করলাম, আপু উত্তর দিলো “Please , enter a number” প্রিন্ট করার কোন দরকার নেই । কেবল শুরু …… . রকিব স্যার থাকাকালীন ক্লাস শুরু করা সম্ভব হয় নি। পরের সেমিস্টারে টার্কে চলে গেলাম। টার্ক থেকে ফিরে জয়েন করবো করবো করে ভয়ে আর করা হলো না। টার্কে কাওনাইন স্যার , রুবায়েত স্যার ,সামিউল স্যার প্রতি শনিবার যেতো। তখন uri এর প্রবলেম সলভ করতাম, সাহায্য নিতাম। . পরের সেমিস্টারেও টুকটাক সলভ করতাম/চেষ্টা করতাম, ডিসেম্বরে ফাইনালি জয়েন করলাম। এর আগে একটা কথা বলি একদিন রাতে ঘুমানোর আগে uva এর 3n+1 বিখ্যাত প্রবলেম (এই সাইটের নামও ঐ বন্ধুর কাছ থেকে পাওয়া। ও তখন এটায় সলভ করে) বহু চিন্তা করে লজিক ঠিক করি। পরের দিন ভোরে উঠে কোড করতে বসি, উত্তর মিলাই। টানা ৭/৮ বারের মতো সাবমিট করে প্রতিবারই WA(Wrong Answer) খাই। উত্তর ঠিকই প্রিন্ট করতেছে কিন্তু wa কেন? . আবার ক্লাসে ফিরে আসি। প্রথমদিন ক্লাসে ২/৩ টা প্রবলেম সলভ করার জন্য বলা হইছিল আমি ১ টা মনে হয় সলভ করতে পারছিলাম। লজ্জায় তাড়াতাড়ি বের হতে চাচ্ছিলাম। আর ঐদিনই জানি আমার ঐ প্রবলেম wa খাওয়ার কারণ ছিল আমি end of file পর্যন্ত ইনপুট নেই নাই। কারণ ঐ জিনিস সম্পর্কে আমার কোন আইডিয়া ছিল না। . প্রথম কন্টেস্ট করতে বসে ২/৩ টা সলভ করতে পারছিলাম ১০ টার মধ্যে। আর প্রথম যারা ছিল তারা ২/৩ ঘন্টার মধ্যেই সব সলভ করে ফেলছে। ঐ রাতেই তাদের জন্য আরেকটা কন্টেস্ট সেট করে দেয়া হতো। তারা যেন প্র্যাকটিস চালু রাখতে পারে। আমি অসহায়ের মতো ঐ কন্টেস্টে গিয়ে আরো ২/৩ টা সলভ করে আসতাম। . আমার uva তে তখন সলিউশন ৪/৫ টা আর প্রথম কয়েকজনের ১৪৫+। আমি সি++ স্ট্রিং নিয়ে অনেক ভুগছি , পরে শিখছি। আমি ক্লাসে সব জিনিস ধরতে পারতাম না, এইটা আজ অবধি সত্য কিন্তু পরে বাসায় এসে ঘেটে দেখে শিখে নিতাম/চেষ্টা করতাম, এখনো তাই করি। একাডেমিক কোর্সের ক্ষেত্রেও তা সত্য। . আমার ৩/৪ নাম্বার ক্লাসেই রাজকিন ভাইয়া BFS, DFS, Trie, Heap শিখাইছিল। কন্সেপ্ট ধরতে পারছি কিন্তু কোডের কিছুই বুঝি নাই । কিন্তু আমি ছাড়ি নাই। . আমি হুমায়ুন আহমেদের বই পড়া মানুষ তা ছাড়া বহু মানুষের কথা শুনছি এবং লিখা পড়ছি। “কচ্ছপের মতো কামড় দিয়ে” ধরে থাকতে পারি। হেরে যাওয়ার আগে হারতে রাজী না কিংবা বিলীন হতে রাজী না। আমি স্লো লার্নার কিন্তু লার্নার। . আমি এই শিখার এবং পার্টিসিপেট করার জার্নিটাকে ইঞ্জয় করছি। আমার বলার মতো কিংবা “সিভি” তে এড করার মতো কোন র‍্যাংক নাই, হবে নাকি জানিও না। . এতোগুলা কথা বলার কারণ ৪ দিনের workshop(BRACU Competitive Programming Workshop, April-May 2017) এ প্রতিদিন মানুষ কমছে যেটা এক্সপেক্টেড ছিল। চেষ্টা না করেই পারবো না বলাটা ঠিক মানানসই না। কেউ কোনকিছুতে ইন্টারেস্টেড ফিল না করলে ভিন্ন কথা। কিন্তু ইন্টারেস্টেড হয়েও নিজের উপর ভরসা না পাওয়াটা সমস্যা। ১/২ মাস চেষ্টা করো , এরপর যদি মনে হয় যে সম্ভব না তাহলে QUIT করো (Wasif ভাইয়া এই কথাটা বলছিল)। কচ্ছপের মতো শুধু পরে থাকাতে আবার সার্থকতা নেই। একটু একটু করে আগাতেও হবে সাথে। . Happy Coding :) . [ লিখাটা যতোটা না অন্যের জন্য তার চেয়ে বেশি নিজের জন্য ] .",
            "url": "https://jabertuhin.github.io/jabers-blog/competitive%20programming/my%20story/2017/05/01/cp-my-journey.html",
            "relUrl": "/competitive%20programming/my%20story/2017/05/01/cp-my-journey.html",
            "date": " • May 1, 2017"
        }
        
    
  
    
        ,"post10": {
            "title": "C++ বেসিক ধারণা, স্ট্যাক(Stack) (Lec - 1.6)",
            "content": "স্ট্যাক(Stack) - একটা ডাটা স্ট্রাকচার যা  জটিল কিছু সমস্যা সমাধানে আমাদের সাহায্য করে থাকে। ব্র্যাকেট ম্যাচিং প্রবলেম কিংবা মেজ(Maze) ট্রাভার্সাল প্রবলেমের মতো জটিল কিছু সমস্যার সমাধান আমরা এর মাধ্যমে করতে পারি। . Pringles এর খালি একটা কৌটা কল্পনা করি(বাহির থেকে যার ভিতরের কোন বস্তু দেখা সম্ভব না), যেটাতে বিভিন্ন লেবেলিং করা বল রাখি(অর্থাৎ এক বলের উপর লিখা 1,আরেকটায় 2 এভাবে)। ৫ টা বল এভাবে রাখি। আমি যদি এখন প্রথম বলটা  বের করতে চাই তাহলে আমাকে কি করতে হবে? আমি তো সরাসরি একেবারে নিচের বলটা তুলতে পারছি না। আমার সেই সুযোগ নেই। ঐ পর্যন্ত পৌঁছাতে হলে আমাকে আগে তার উপরের বলগুলো সরাতে হবে। . প্রথমে উপর থেকে ৪ টা বল বের করে আনতে হবে, এরপর আমি ৫ নাম্বার বলটা যেটা সবার প্রথমে রেখেছিলাম সেটা বের করতে পারবো। Stack , LIFO রুলস ফলো করে (Last In First Out ). . ‘ [ ’ -&gt; এই চিহ্ন দিয়ে pringles(Stack) এর তলানি(Bottom) বুঝানো হচ্ছে। . ‘ ( ’ -&gt; এই চিহ্ন দিয়ে pringles(Stack) এর মুখ(door) বুঝানো হচ্ছে। মানে একমাত্র এই  মুখ দিয়েই বল রাখা কিংবা বের করা সম্ভব। . প্রথমে স্ট্যাকের ভিতরের চিত্র অনেকটা এইরকম হবে(Stack পুরো খালি) -&gt; [( . সবার প্রথমে 1 লেবেল করা বল রাখি -&gt; [1 ( . এরপর 4 লেবেল করা বল রাখি -&gt; [1 . 4 ( . এরপর 5  লেবেল করা বল রাখি -&gt; [1 . 4 . 5 ( . এরপর 2  লেবেল করা বল রাখি -&gt; [1 . 4 . 5 . 2 ( . এরপর 3  লেবেল করা বল রাখি -&gt; [1 . 4 . 5 . 2 . 3 ( . একটার উপরে আরেকটা বল রাখা হচ্ছে। এটা হলো আমার বর্তমানে স্ট্যাকের দশা। এই কাজটা করার জন্য সবার প্রথমে  আমাকে স্ট্যাক(Stack) টা ডিক্লেয়ার করতে হবে। এইভাবে- . stack stck_variable;     [ stack variable name] . এইবার আমরা যে বল রাখার কাজটা করেছি সেটা করতে হবে এইভাবে . stck_variable.push(1); . stck_variable.push(4); . stck_variable.push(5); . stck_variable.push(2); . stck_variable.push(3); . এখন আমি যদি জানতে চাই সবার উপরে কোন বলটা আছে, সেক্ষেত্রে আমার কমান্ডটা হবে এই ধরনের -&gt; . stck_variable.top(); . এইটা সবার উপরের ভ্যালুটা রিটার্ন করবে। স্ট্যাক থেকে বের করবে না। জিনিসটা অনেকটা এরকম যে - উঁকি দিয়ে স্ট্যাকের উপরের ভ্যালু দেখে আমাকে জানিয়ে দেয়া। . আর আমি যদি ভ্যালু বের করে অর্থাৎ বল বের করতে চাই স্ট্যাক থেকে সেক্ষেত্রে কমান্ড হবে (ডিলেট করে ফেলা বলা চলে)-&gt; . stck_variable.pop(); . এইটা কোন কিছু রিটার্ন করবে না । শুধু উপরে থেকে বলটা তুলে ফেলবে । . আর আমি যে স্ট্যাকে কাজ করছি আমার স্ট্যাকে কি আদৌ আর কোন বল অর্থাৎ ভ্যালু আছে কি না তা দেখার জন্য -&gt; . stck_variable.empty(); . লিখতে হয় । এটা true/false রিটার্ন করে । স্ট্যাক খালি থাকলে true রিটার্ন করবে অন্যথা false. . স্ট্যাক খালি থাকার পরেও যদি আমি কোন ভ্যালু বের করে আনতে চাই সেক্ষেত্রে ভুল হয়ে গেলো না? সেক্ষেত্রে runtime error দিবে। . আর স্ট্যাকে বর্তমানে কতগুলি এলিমেন্ট আছে তা জানার জন্য -&gt; . stck_variable.size(); . লিখতে হয়ে  এইটা স্ট্যাকে বিদ্যমান এলিমেন্টের সংখ্যা রিটার্ন করে । . এইবার একটা প্রবলেম ট্রাই করিঃ . Bracket Matching -&gt; “()” এইটা ভ্যালিড  কিন্তু “((”এইটা নয় । . একটা স্ট্রিং ইনপুট দেয়া হবে যেখানে কোন স্পেস থাকবে না , থাকবে শুধু ‘(’ and ‘)’ ক্যারেক্টার । . আউটপুটঃ . Print “Valid” if the expression is valid ,otherwise “Not Valid” . ==&gt; . এইখানে আমার এপ্রোচটা হবে অনেকটা এই রকম আমি কোন ওপেনিং ব্র্যাকেট পেলে তা স্ট্যাকে পুশ করে রাখবো আর ক্লোজিং ব্র্যাকেট পেলে স্ট্যাকের টপ এলিমেন্ট চেক করবো। যদি টপ এলিমেন্ট থাকে (যেটা এক্ষেত্রে একমাত্র ‘(’ ওপেনিং ব্র্যাকেট হওয়াই সম্ভব) তবে তা পপ করে বের দিবো। . আর যদি ক্লোজিং ব্র্যাকেট পাই কিন্তু স্ট্যাক ফাঁকা থাকে তার মানে একটা ক্লজিং ব্র্যাকেট অতিরিক্ত আছে। সুতরাং ভ্যালিড না। . কিংবা আমার ইনপুট নেয়া পুরো স্ট্রিং চেক করা শেষ এরপরও দেখলাম স্ট্যাকে কিছু অপেনিং ব্র্যাকেট রয়ে গেছে তার মানে দাঁড়াচ্ছে এক্সপ্রেশনটা ভুল। . এখানে লজিক হচ্ছে অপেনিং আর ক্লোজিং ব্র্যাকেট সবসময় জোড়ায় জোড়ায় থাকবে। এর ব্যতিক্রম হলেই এক্সপ্রেশনটা ভুল হয়ে যাবে। এইবার কোডটা দেখি- . #include &lt;bits/stdc++.h&gt; using namespace std; int main() { string line; cin&gt;&gt;line; int sz = line.size(); // input string size stack&lt;char&gt; k; bool shotto = true; for(int j =0;j&lt;sz;j++){ if(line[j] == &#39;(&#39;){ // opening bracket found and storing it in the stack k.push(line[j]); } else{ // closing bracket found if(k.empty()){ //checking wheter the stack is empty or not . shotto = false; break; } char c = k.top(); // a pair matched . so deleting them k.pop(); } } if(k.empty() &amp;&amp; shotto == true){ printf(&quot;Valid n&quot;); } else{ printf(&quot;Not Valid n&quot;); } return 0; } . You can try - UVA 673 (Parentheses Balance) . You can also read and practice here - Basics of Stacks .",
            "url": "https://jabertuhin.github.io/jabers-blog/c++/competitive%20programming/2017/05/01/cpp-basic-stack.html",
            "relUrl": "/c++/competitive%20programming/2017/05/01/cpp-basic-stack.html",
            "date": " • May 1, 2017"
        }
        
    
  
    
        ,"post11": {
            "title": "C++ বেসিক ধারণা, ভেক্টর(Vector) (Lec - 1.5)",
            "content": "আমরা সবাই মোটামোটি Array সম্পর্কে জানি । একটা নির্দিষ্ট পরিমাণ দৈর্ঘ্যের হতে হয় সেই এরেকে । . এরে ডিক্লেয়ারেশনটা অনেকটা এইরকম -&gt; int arr[n]; . অর্থাৎ এরে ডিক্লেয়ার করার ক্ষেত্রে আমাকে এর দৈর্ঘ্য বলে দিতে হয় । এমন যদি কখনো হয় আমাকে কতগুলি নাম্বার স্টোর করতে হবে কিন্তু সঠিক নাম্বার আমাকে বলা থাকবে না (n এর মানটা আমাকে দেয়া থাকবে না/বলে দেয়া হবে না) । সেক্ষেত্রে আমি কোনভাবেই এরে ডিক্লেয়ার করতে পারছি না । কারণ যে দৈর্ঘ্যেরই এরে ডিক্লেয়ার করি না কেন(অনেক বড় লেন্থের )  তার চেয়ে একটা নাম্বার বেশি দিলেই আমার কোড কাজ করবে না । এইসব ক্ষেত্রে আমরা ভেক্টর ব্যবহার করে থাকি । . [ জাভাতে ArrayList  নামে এইরকম একটা জিনিস আছে । তবে এইখানে আমরা সি++ এর ভেক্টর নিয়েই কথা বলবো ] . . এই ছবিটা একটা ট্রান্সপারেন্ট টিউবের । ছবিতে যদিও টিউবের দুই পাশ বন্ধ । কিন্তু আমরা চিন্তা করবো এক পাশ বন্ধ অন্য পাশ খোলা এইরকম একটা টিউবের । আর টিউবের দৈর্ঘ্য infinity ধরি আপাতত । এখন টিউবে “1” লেবেল করা একটা বল রাখি , এভাবে করে মোট ১০ টা বল রাখি যেগুলোর উপরে একটা করে নাম্বার লিখা(1,2,3,4,5,6,7,8,9,10)। . তাহলে টিউবে এখন ১০ টা বল আছে । আমি বাহির থেকে দেখতে পারছি টিউবের ভেতর কি কি বল আছে(মানে কোন বলের নাম্বার কত) । . এখন একটা প্রবলেম সলভ করার চেষ্টা করি (থিওরিটিকালি)। . “রায়হান এর ব্যাপারে একটা মজার ব্যাপার ওর ছোট বোন মিলি জানতে পারে । রায়হান ওলট পালোট করে রাখা কোন জিনিস দেখলেই রেগে যায় আর তা সাথে ঠিক ঠিক করে রাখে । যেমন ওর টেবিলের উপরে রাখা বইগুলো ছোট থেকে বড় আকারে সাজানো । . আর অন্যদিকে মিলি হলো অনেকটা অলস । ওর ঘরের সব পুতুল এলোমেলো । ওর মা ওকে আজকের মধ্যে সব গোছাতে বলেছে । মিলি যেহেতু অলস তাই ও রায়হানকে ডেকে রুমে নিয়ে এলো । রায়হান মিলিকে কিছুক্ষণ বকা ঝকা করেই রুম গোছাতে লেগে গেলো । . ইনপুটঃ . মিলির রুমে রাখা প্রত্যেকটা পুতুলের উচ্চতা দেয়া থাকবে । আর মিলি এতোই অলস যে ও গুনে রাখে নি ওর রুমে কতগুলো পুতুল আছে । আর তাই রায়হানও জানে না কতগুলো পুতুল ওকে সাজাতে হবে(ছোট থেকে বড় এই সিকুয়েন্সে ) । . আউটপুটঃ . রায়হান সাজানোর পরে পুতুলগুলো কিভাবে আছে সেটা । . Sample Input: . 10 7 3 1 2 4 6 5 9 8 . Sample Output: . 1 2 3 4 5 6 7 8 9 10 . Solution: . এই প্রবলেম কিভাবে সলভ করবে?  তোমার তো পুতুলের সংখ্যা জানা নেই? Array দিয়ে কোনভাবেই কাজ করতে পারছো না। . হ্যাঁ বলতে পারো int arr[1000000] এইটা যদি করি? . আমি যদি এর চেয়ে একটা বেশিও ইনপুট দেই, তাহলে কাজ করবে না কোড সঠিকভাবে। . ভেক্টরের কিছু জিনিস দেখে এরপর কোডে যাই। . ভেক্টর ডিক্লেয়ারেশন -&gt; vector  variable_name; . Example: vector vNum; . vector vName; . ভেক্টর সাইজ জানার জন্য (অর্থাৎ ভেক্টরে কতগুলো এলিমেন্ট আমি রাখলাম সেটা জানার জন্য) -&gt; variable_name.size(); . Example: int sz = vNum.size(); // যেই নাম্বারটা(ভেক্টরের সাইজ) রিটার্ন করবে তা একটা ভেরিয়েবলে সেভ করে রাখছি। . উপরে টিউবে ১০ নাম্বার রেখে ছিলাম তাহলে এইখানে sz = 10 হয়ে যাবে। . এইবার আসি ভেক্টরে নাম্বার রাখবো কিভাবে? . Variable_name.push_back(num); . মানে আমার ভেক্টরের টিউবে num ভেরিয়েবলের উপাদানটা পুশ হবে। . [] এইটা যদি ভেক্টরের প্রাথমিক অবস্থা হয়। . vNum.push_back(1); . এই কমান্ডের পরে হবে -&gt; [1] . vNum.push_back(2); . এই কমান্ডের পরে হবে -&gt; [1,2] . সরাসরি নাম্বার না দিয়ে ঐ জায়গায় যে ভেরিয়েবলের জিনিস আমি ভেক্টরে পুশ করতে চাই সেটি দিলেও হবে। . cin&gt;&gt;num; vNum.push_back(num); . এই কমান্ডের পরে হবে -&gt; [1,2,10] // num = 10 ছিল মনে করি . এতোটুকুই নতুন বলা যায় । . আর ভেক্টর ট্রাভার্সাল সাধারণ এরের মতোই । . বর্তমানে আমাদের ভেক্টর আছে এই অবস্থায় -&gt; [1,2,10] . এখন আমি নাম্বারগুলি প্রিন্ট করে দেখতে চাই , ইউজার কি কি নাম্বার ইনপুট দিয়েছে। . int sz = vNum.size(); for(int i = 0;i&lt;sz;i++){ cout&lt;&lt;vNum[i]&lt;&lt;endl; } . ভেক্টরেরও ইন্ডেক্সিং শুরু 0 (জিরো) থেকে । . ভেক্টরের আরো বিভিন্ন ধরনের ফাংশন আছে , গুগল করে শিখে নিতে পারো । এই লিখায় আমি বেসিক ধারণা দিচ্ছি । . Solution for the above problem: . #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ vector&lt;int&gt; v; int num; while(scanf(&quot;%d&quot;,&amp;num) == 1){ v.push_back(num); } sort(v.begin(),v.end()); int sz = v.size(); for(int i = 0;i&lt;sz;i++)  cout&lt;&lt;v[i]&lt;&lt;endl; } . সি++ এর sort ফাংশন ব্যবহার করে ভেক্টর সোর্ট করতে চাইলে . sort(vector_name.begin(), vector_name.end()); . এইভাবে লিখতে হয় , ascending অর্ডারে সোর্ট করে দিবে । . For more vector functions - vector .",
            "url": "https://jabertuhin.github.io/jabers-blog/c++/competitive%20programming/2017/04/30/cpp-basic-vector.html",
            "relUrl": "/c++/competitive%20programming/2017/04/30/cpp-basic-vector.html",
            "date": " • Apr 30, 2017"
        }
        
    
  
    
        ,"post12": {
            "title": "C++ এর বেসিক ধারণা(Lec – 0.9)",
            "content": "More about string . আগেই বলেছি স্ট্রিং হলো একটা ক্যারেক্টার এরে। এরের ক্ষেত্রে কি হয়? [0],[1],[2] ইন্ডেক্স অনুযায়ী ভ্যালুর এক্সেস আছে। সি++ এর ক্ষেত্রে কোন ক্যারেক্টার নিয়ে কাজ করতে হলে string_variable_name[index] এভাবেই ঐ নির্দিষ্ট কারেক্টার পাওয়া যায়। . আবার যদি ASCII ভ্যালু প্রয়োজন হয় – int val = string_variable_name[index]; করলেই ASCII ভ্যালু সরাসরি পেয়ে যাচ্ছি। . Stringstream . ইউজার একসাথে তার নাম আর মাসিক আয় ইনপুট দিবে। আর আমাকে তা আলাদা করতে হবে (সঠিক উদাহরণ না যদিও) . Jannat 8000 ইনপুট নিলাম string হিসেবে। . string data; getline(cin, data); . এখন দুইটা তথ্য আলাদা করবো কিভাবে? একটা তো স্ট্রিং আরেকটা তো ইন্টিজার। . stringstream ss(data);//স্ট্রিং টা স্ট্রিং স্ট্রিমের ভিতরে পাস করছি . এইটা একটা দারুন কাজ করবে। “Space” এর ভিত্তিতে পুরো স্ট্রিং টা কে পার্ট পার্ট করে ভাগ করে ফেলবে । আর তা ss এ সেভ করা থাকবে। . string name; int money; এখন ss&gt;&gt;name;// name = jannat ss&gt;&gt;money;// অনেকটা cin&gt;&gt; এর মতো কাজ করছে . money = 8000 . তাহলে ও রাখার সময় কি ধরনের(ডাটা টাইপ) ভেরিয়েবলে সেভ করছি সেই অনুযায়ী রাখবে। . [উদাহরণটা বুঝার জন্য সহজ হবে এই জন্য দেয়া । তবে বিভিন্ন প্রবলেম সলভ করার ক্ষেত্রে এইটা বেশ কাজে লাগবে । প্রতি টেস্ট কেসে কতগুলি নাম্বার থাকবে তা যদি উল্লেখ করা না থাকে সেক্ষেত্রে এভাবে স্ট্রিং হিসেবে তা ইনপুট নিতে হয় । Maximum Gcd(UVA) দেখতে পারো।] . Taking several inputs . বিভিন্ন প্রবলেম স্টেটমেন্টের ইনপুটে বলা থাকে ইউজার বলে দিবে সে কয়টা ইনপুট দিবে as in Test cases। ধরলাম , Test Cases = 5। এর পর পরবর্তী ৫ লাইনে প্রবলেমের উপর নির্ভর করে ইউজার ইনপুট দিবে । Loop চালিয়ে প্রতিটা টেস্ট কেসের জন্য সঠিকভাবে ইনপুট নেয়া সম্ভব । আমি নিজে প্রথমে যে জায়গাটাতে ভুল করলাম তা হলো ৫ টা টেস্ট কেসের রেজাল্ট সেভ করে পরবর্তীতে একসাথে প্রিন্ট করার কথা ভাবলাম । কিন্তু সেটার কোন প্রয়োজন নেই । প্রথমে প্রথম টেস্ট কেসের জন্য কাজ করে তার উপযোগী আউটপুট প্রিন্ট করে দিলেই হবে। এরপরের টেস্ট কেসের জন্য ইনপুট নিবো আর সেটার জন্য আউটপুট জেনারেট করবো। এভাবে কাজ করতে থাকবো। . Example -&gt; . int test; for(int i = 1;i&lt;=test;i++){ string name; cin&gt;&gt;name; cout&lt;&lt;name&lt;&lt;endl; }//এই প্রোগ্রামের কাজ পাঁচবার নাম ইনপুট দিলে প্রতিবার সেটা প্রিণ্ট করতে হবে। . উপরের পদ্ধতিতে অনেকেই পারবে। সমস্যা হয়, আমার নিজের ক্ষেত্রেও হয়েছে – end of file পর্যন্ত ইনপুট নেয়া। বলে দেয়া থাকবে না ইনপুট কতগুলি দেয়া হবে। মানে উপরের উদাহরণের মতো Test Cases এর সংখ্যা ইউজার বলবে না। সে মনের ইচ্ছা মতো ইনপুট দিতে থাকলো এরপর ক্লান্ত হয়ে কিংবা অনিচ্ছা বসত ইনপুট দেয়া বন্ধ করে দিলো। সে তখন চাবে সে যে এতক্ষণ ইনপুট দিলো তার আউটপুটগুলো দেখতে ( ক্ষেত্রেও প্রতিটা ক্ষেত্রে উপযুক্ত কাজ করে আউটপুট প্রিণ্ট করলেই চলবে)। এটাই end of file পর্যন্ত ইনপুট নেয়া। যখন আর কোন কাজ করার থাকবে না তখন যেন প্রোগ্রাম বন্ধ হয়ে যায়। . Example -&gt; আগের প্রোগ্রামটাই . string name; while(cin&gt;&gt;name){ cout&lt;&lt;name&lt;&lt;endl; }//এখানে ইউজার নাম যখন ইনপুট দিবে তখনই সেটা আউটপুট হিসেবে শো করবে । . For practice - . Uva – 10424, 10370, 12554, 11743, 12195, 494, 488, 12250, 12289, 12577, 12403, 483. . [পরবর্তী লিখায় কয়েকটা প্রবলেম নিয়ে আলোচনা করবো । বিগত দুটি লিখার উপর ভিত্তি করে যেগুলো সলভ করা সম্ভব ।] .",
            "url": "https://jabertuhin.github.io/jabers-blog/c++/competitive%20programming/2017/04/30/cpp-basic-concept-lec-point-9.html",
            "relUrl": "/c++/competitive%20programming/2017/04/30/cpp-basic-concept-lec-point-9.html",
            "date": " • Apr 30, 2017"
        }
        
    
  
    
        ,"post13": {
            "title": "C++ এর বেসিক ধারণা(Lec - 0.5)",
            "content": "[লিখাটা মূলত তাদের জন্য যাদের প্রোগ্রামিং ল্যাঙ্গুয়েজের বেসিক সম্পর্কে ধারণা আছে , অন্য কোন ল্যাঙ্গুয়েজ জানে । এখন সি++ শিখতে ইচ্ছুক।] . প্রতিটা প্রোগ্রামিং ভাষায় কিছু বিল্টিন এবং মোডিফাইড কিছু ডাটা টাইপ থাকে । সি++ এর ক্ষেত্রে – bool(boolean, char , int , float , double , long long int , long long double , string .( আরো আছে , এগুলোই যথেষ্ট প্রথমদিকে) . কোড স্ট্রাকচার – . #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ // মূল কোড এখানে থাকবে return 0; } . ইনপুটঃ . একটা পদ্ধতি . cin» variable_name; . Example – int number; cin»number; . (ইউজারের কাছ থেকে নাম্বার নিয়ে number ভেরিয়েবলে স্টোর করবে ) . cin»number1»number2»number3; . এভাবে একাধিক ইনপুট নেয়া সম্ভব । . string name; cin»name»number; . আলাদা ডাটা টাইপ হলেও এভাবে ইনপুট নেয়া সম্ভব । . আরেকটা পদ্ধতি – . এই পদ্ধতি পূর্বের চেয়ে দ্রুত কাজ করে । এই জন্য প্রবলেম সল্ভিং এর ক্ষেত্রে এটি ব্যবহার করা ভালো । . scanf(); int number; scanf(&quot;%d&quot;,&amp;number); . scanf – এর ক্ষেত্রে দুইটা অংশ একটি ডাটা টাইপ নির্দেশ করে আরেকটি এড্রেস । শুধু ভেরিয়েবলের নাম দিলে এই ক্ষেত্রে হবে না । ভেরিয়েবল নামের পূর্বে ‘ &amp; ‘ সাইন ব্যবহার করতে হবে , যা মূলত এড্রেস স্পেসিফাই করে । . int (%d),double(%lf),long long int (%lld),char(%c); . String, স্ট্রিং মূলত ক্যারেক্টারের (char) এর array । স্ট্রিং ডিক্লেয়ারেশন – . string name cin»name;//For string name এক্ষেত্রে প্রয়োজনীয় ক্যারেক্টার নিয়ে স্ট্রিং তৈরি হয় । . যার দৈর্ঘ্য জানার জন্য- . name.size(); . ব্যবহার করা যায়। . এই সব ক্ষেত্রে স্ট্রিং হিসেবে ধরা হয় স্পেস পাওয়ার আগ পর্যন্ত। মানে কেবল মাত্র একটা শব্দ মেমরিতে সেভ হবে। মাঝে মাঝে একটা পুরো লাইন সেভ করার দরকার পড়তে পারে। স্পেসসহ স্ট্রিং ইনপুট নেয়ার ক্ষেত্রে- . getline(cin,name); . কোন নাম্বারকে স্ট্রিং এ পরিবর্তন করার জন্য- . string num = to_string(string_name) . আর কোন স্ট্রিং কে নাম্বারে কনভার্ট করার জন্য – int n = atoi(variable_name) *** কোন ইন্টিজার/ নাম্বার ইনপুট নেয়ার পরে যদি স্ট্রিং ইনপুট নিতে হয় । সেক্ষেত্রে getchar() ইউজ করতে হয় স্ট্রিং ইনপুটের আগে । আউটপুট – cout অথবা printf() এই দুইটা ব্যবহার করা হয় । . NOTE: tutorailspoint অথবা cplusplus এই দুইটা ওয়েবসাইট থেকে বিস্তারিত জানা যাবে । সুবিন ভাইয়ের বই “ প্রোগ্রামিং –এ- হাতে খড়ি ” বইটা বেসিক ক্লিয়ার করার জন্য সর্বোত্তম আউটপুটের বিস্তারিত এবং কোন ডাটা টাইপ – ( int , long long int )/( double , float )কখন , কেন ব্যবহার করা হয় – নিজে থেকে জেনে নেয়ার জন্য বলা হচ্ছে। . সোর্ট- কোন এরে সোর্ট করার ক্ষেত্রে সি++ এ বিল্টিন ফাংশন(মেথড) আছে, sort()। . int arr[10]; . ইনপুট নিলাম ১০ টা এখন তাদের আমি সোর্ট করতে চাই। . sort(arr, arr+10) . এখানে দুইটা অংশ প্রথম অংশে এরের কোথা থেকে শুরু করবো সোর্ট করা আর এরপরের অংশে শুরু থেকে কোন পর্যন্ত আমি সোর্টেড চাই সেটা। এই সোর্টেড ফাংশন এসেন্ডিং অর্ডারে সোর্ট করে দিবে আমাকে। [ডিসেন্ডিং অর্ডারে সোর্ট করতে চাইলে কি করতে হবে ? - সার্চ করো] . সি++ এ এরে ডিক্লেয়ার করার পরে তার প্রতি ঘরে গার্বেজ ভ্যালু থাকে । ডিক্লেয়ার করে প্রিন্ট করে দেখতে পারো। একটা কাজ করা যায়, আরেকটা ফাংশন আছে – memset()। . memset(arr, 0, sizeof(arr)) . এরের নাম , কি মান বসাতে চাচ্ছি , এরের সাইজ। 0 আর -1 এই দুইটা মানের ক্ষেত্রে এই memset ব্যবহার করা যায়। bool blArr[10] বুলিয়ান এরের ক্ষেত্রে . memset(blArr,true/false,sizeof(blArr)) . *true/false যখন যেটা দিয়ে কাজ করার প্রয়োজন। . এই জ্ঞান দিয়ে- . Uva –&gt; 11727, 12279, 12250, 12289, 12403, 12577, 11172, 11799 এগুলো সলভ করা সম্ভব। . *** UVA তে একাউন্ট খুলো, uhunt এ যাও। নিজের ইউজারনেম সাবমিট করো । competitive programming exercises এর introduction -&gt; All সিলেক্ট করো। এরপর লেভেল দেখে প্রবলেম ওপেন করে সলভ করার চেষ্টা করো। . Happy Coding :) .",
            "url": "https://jabertuhin.github.io/jabers-blog/c++/competitive%20programming/2017/04/29/cpp-basic-lec-point-5.html",
            "relUrl": "/c++/competitive%20programming/2017/04/29/cpp-basic-lec-point-5.html",
            "date": " • Apr 29, 2017"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I am currently working at Infolytx as a Software Engineer-I. I completed my graduation from BRAC University in Computer Science. . Who am I? . Once a poet, now a deep learning practitioner with a software engineering mindset. Therefore, I am a philosopher with a little bit of logical reasoning. Currently focusing on deep diving into the things that I once said or believed I know. . Contact me . mir.mohammad.jaber at g.bracu.ac.bd .",
          "url": "https://jabertuhin.github.io/jabers-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jabertuhin.github.io/jabers-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}