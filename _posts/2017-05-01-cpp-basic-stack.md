---
layout: post
title: C++ বেসিক ধারণা, স্ট্যাক(Stack) (Lec - 1.6)
description: Learn about stack operations and use cases.
comments: true
categories: [C++, Competitive Programming]
---
স্ট্যাক(Stack) - একটা ডাটা স্ট্রাকচার যা  জটিল কিছু সমস্যা সমাধানে আমাদের সাহায্য করে থাকে। ব্র্যাকেট ম্যাচিং প্রবলেম কিংবা মেজ(Maze) ট্রাভার্সাল প্রবলেমের মতো জটিল কিছু সমস্যার সমাধান আমরা এর মাধ্যমে করতে পারি।

Pringles এর খালি একটা কৌটা কল্পনা করি(বাহির থেকে যার ভিতরের কোন বস্তু দেখা সম্ভব না), যেটাতে বিভিন্ন লেবেলিং করা বল রাখি(অর্থাৎ এক বলের উপর লিখা 1,আরেকটায় 2 এভাবে)। ৫ টা বল এভাবে রাখি। আমি যদি এখন প্রথম বলটা  বের করতে চাই তাহলে আমাকে কি করতে হবে? আমি তো সরাসরি একেবারে নিচের বলটা তুলতে পারছি না। আমার সেই সুযোগ নেই। ঐ পর্যন্ত পৌঁছাতে হলে আমাকে আগে তার উপরের বলগুলো সরাতে হবে।

প্রথমে উপর থেকে ৪ টা বল বের করে আনতে হবে, এরপর আমি ৫ নাম্বার বলটা যেটা সবার প্রথমে রেখেছিলাম সেটা বের করতে পারবো। Stack , LIFO রুলস ফলো করে (Last In First Out ).

‘ [ ’ -> এই চিহ্ন দিয়ে pringles(Stack) এর তলানি(Bottom) বুঝানো হচ্ছে।

‘ ( ’ -> এই চিহ্ন দিয়ে pringles(Stack) এর মুখ(door) বুঝানো হচ্ছে। মানে একমাত্র এই  মুখ দিয়েই বল রাখা কিংবা বের করা সম্ভব।

প্রথমে স্ট্যাকের ভিতরের চিত্র অনেকটা এইরকম হবে(Stack পুরো খালি) -> [(

সবার প্রথমে 1 লেবেল করা বল রাখি -> [1 (

এরপর 4 লেবেল করা বল রাখি -> [1 . 4 (

এরপর 5  লেবেল করা বল রাখি -> [1 . 4 . 5 (

এরপর 2  লেবেল করা বল রাখি -> [1 . 4 . 5 . 2 (

এরপর 3  লেবেল করা বল রাখি -> [1 . 4 . 5 . 2 . 3 (

একটার উপরে আরেকটা বল রাখা হচ্ছে। এটা হলো আমার বর্তমানে স্ট্যাকের দশা। এই কাজটা করার জন্য সবার প্রথমে  আমাকে স্ট্যাক(Stack) টা ডিক্লেয়ার করতে হবে। এইভাবে-

> stack<int> stck_variable;     [ stack<data_type> variable name]

এইবার আমরা যে বল রাখার কাজটা করেছি সেটা করতে হবে এইভাবে

> stck_variable.push(1);

> stck_variable.push(4);

> stck_variable.push(5);

> stck_variable.push(2);

> stck_variable.push(3);


এখন আমি যদি জানতে চাই সবার উপরে কোন বলটা আছে, সেক্ষেত্রে আমার কমান্ডটা হবে এই ধরনের ->

> stck_variable.top();

এইটা সবার উপরের ভ্যালুটা রিটার্ন করবে। স্ট্যাক থেকে বের করবে না। জিনিসটা অনেকটা এরকম যে - উঁকি দিয়ে স্ট্যাকের উপরের ভ্যালু দেখে আমাকে জানিয়ে দেয়া।

আর আমি যদি ভ্যালু বের করে অর্থাৎ বল বের করতে চাই স্ট্যাক থেকে সেক্ষেত্রে কমান্ড হবে (ডিলেট করে ফেলা বলা চলে)->

> stck_variable.pop();

এইটা কোন কিছু রিটার্ন করবে না । শুধু উপরে থেকে বলটা তুলে ফেলবে ।

আর আমি যে স্ট্যাকে কাজ করছি আমার স্ট্যাকে কি আদৌ আর কোন বল অর্থাৎ ভ্যালু আছে কি না তা দেখার জন্য ->

> stck_variable.empty();

লিখতে হয় । এটা true/false রিটার্ন করে । স্ট্যাক খালি থাকলে true রিটার্ন করবে অন্যথা false.

স্ট্যাক খালি থাকার পরেও যদি আমি কোন ভ্যালু বের করে আনতে চাই সেক্ষেত্রে ভুল হয়ে গেলো না? সেক্ষেত্রে runtime error দিবে।

আর স্ট্যাকে বর্তমানে কতগুলি এলিমেন্ট আছে তা জানার জন্য ->

> stck_variable.size();

লিখতে হয়ে  এইটা স্ট্যাকে বিদ্যমান এলিমেন্টের সংখ্যা রিটার্ন করে ।

এইবার একটা প্রবলেম ট্রাই করিঃ

Bracket Matching -> “()” এইটা ভ্যালিড  কিন্তু “((”এইটা নয় ।

একটা স্ট্রিং ইনপুট দেয়া হবে যেখানে কোন স্পেস থাকবে না , থাকবে শুধু ‘(’ and ‘)’ ক্যারেক্টার ।

আউটপুটঃ

Print "Valid" if the expression is valid ,otherwise "Not Valid"

==>

এইখানে আমার এপ্রোচটা হবে অনেকটা এই রকম আমি কোন ওপেনিং ব্র্যাকেট পেলে তা স্ট্যাকে পুশ করে রাখবো আর ক্লোজিং ব্র্যাকেট পেলে স্ট্যাকের টপ এলিমেন্ট চেক করবো। যদি টপ এলিমেন্ট থাকে (যেটা এক্ষেত্রে একমাত্র ‘(’ ওপেনিং ব্র্যাকেট হওয়াই সম্ভব) তবে তা পপ করে বের দিবো।

আর যদি ক্লোজিং ব্র্যাকেট পাই কিন্তু স্ট্যাক ফাঁকা থাকে তার মানে একটা ক্লজিং ব্র্যাকেট অতিরিক্ত আছে। সুতরাং ভ্যালিড না।

কিংবা আমার ইনপুট নেয়া পুরো স্ট্রিং চেক করা শেষ এরপরও দেখলাম স্ট্যাকে কিছু অপেনিং ব্র্যাকেট রয়ে গেছে তার মানে দাঁড়াচ্ছে এক্সপ্রেশনটা ভুল।

এখানে লজিক হচ্ছে অপেনিং আর ক্লোজিং ব্র্যাকেট সবসময় জোড়ায় জোড়ায় থাকবে। এর ব্যতিক্রম হলেই এক্সপ্রেশনটা ভুল হয়ে যাবে। এইবার কোডটা দেখি-

```cpp
#include <bits/stdc++.h>
 
using namespace std;
 
int main()
{
        string line;
        cin>>line;
        int sz = line.size(); // input string size
        stack<char> k;
        bool shotto = true; 
        for(int j =0;j<sz;j++){
            if(line[j] == '('){ // opening bracket found and storing it in the stack
               k.push(line[j]);
            }
            else{ // closing bracket found
                if(k.empty()){  //checking wheter the stack is empty or not .
                    shotto = false;
                    break;
                }
                char c = k.top(); // a pair matched . so deleting them
                k.pop();
           }
        }
        if(k.empty() && shotto == true){
            printf("Valid\n");
        }
        else{
            printf("Not Valid\n");
        }
    return 0;
}
```

You can try - [UVA 673 (Parentheses Balance)](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=614)

You can also read and practice here - [Basics of Stacks](https://www.hackerearth.com/practice/data-structures/stacks/basics-of-stacks/tutorial/)